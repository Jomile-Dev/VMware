# VM CPU Contention and NUMA Metrics - Simple Average/Median Report
# Configuration
$BatchSize = 100
$ThrottleLimit = 10
$StatDays = 7  # Number of days to look back (adjust based on uptime)

# Connect to vCenter (modify as needed)
# Connect-VIServer -Server your-vcenter.domain.com

$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

Write-Host "Collecting VM inventory..." -ForegroundColor Cyan
$vms = Get-VM | Where-Object {$_.PowerState -eq "PoweredOn"}
$totalVMs = $vms.Count
Write-Host "Found $totalVMs powered-on VMs" -ForegroundColor Green

# Define metrics to collect
$metrics = @(
    'cpu.ready.summation',
    'cpu.wait.summation',
    'cpu.costop.summation',
    'cpu.maxlimited.summation',
    'cpu.usage.average',
    'cpu.usagemhz.average',
    'mem.active.average'
)

# Try to get NUMA metrics (may not be available on all VMs)
$numaMetrics = @(
    'numa.memoryLocal.average',
    'numa.memoryRemote.average'
)

# Calculate start time
$startTime = (Get-Date).AddDays(-$StatDays)

Write-Host "Collecting statistics for the last $StatDays days..." -ForegroundColor Cyan
Write-Host "This may take a few minutes for $totalVMs VMs..." -ForegroundColor Yellow

# Process VMs in batches
$results = [System.Collections.ArrayList]::new()
$batches = [math]::Ceiling($vms.Count / $BatchSize)

for ($i = 0; $i -lt $batches; $i++) {
    $batchStart = $i * $BatchSize
    $batchEnd = [math]::Min(($i + 1) * $BatchSize - 1, $vms.Count - 1)
    $currentBatch = $vms[$batchStart..$batchEnd]
    
    $batchNum = $i + 1
    Write-Host "Processing batch $batchNum of $batches..." -ForegroundColor Yellow
    
    # Get CPU/Memory stats for batch
    try {
        $batchStats = Get-Stat -Entity $currentBatch -Start $startTime -Stat $metrics -ErrorAction SilentlyContinue
        $batchNumaStats = Get-Stat -Entity $currentBatch -Start $startTime -Stat $numaMetrics -ErrorAction SilentlyContinue
    } catch {
        Write-Host "  Error retrieving stats: $_" -ForegroundColor Red
        continue
    }
    
    # Combine all stats
    $allBatchStats = @($batchStats) + @($batchNumaStats)
    
    # Group by VM
    $statsByVM = $allBatchStats | Group-Object -Property Entity
    
    # Process each VM
    foreach ($vm in $currentBatch) {
        $vmStats = ($statsByVM | Where-Object {$_.Name -eq $vm.Name}).Group
        
        if (-not $vmStats -or $vmStats.Count -eq 0) {
            Write-Host "  No stats for $($vm.Name)" -ForegroundColor Gray
            continue
        }
        
        # Group by metric
        $statsByMetric = $vmStats | Group-Object -Property MetricId -AsHashTable
        
        # CPU Ready (convert from milliseconds to percentage)
        $cpuReadyValues = $statsByMetric['cpu.ready.summation']
        $cpuReadyPercents = @()
        if ($cpuReadyValues) {
            $cpuReadyPercents = $cpuReadyValues | ForEach-Object { ($_.Value / 20000) * 100 }
        }
        
        # CPU Wait
        $cpuWaitValues = $statsByMetric['cpu.wait.summation']
        $cpuWaitPercents = @()
        if ($cpuWaitValues) {
            $cpuWaitPercents = $cpuWaitValues | ForEach-Object { ($_.Value / 20000) * 100 }
        }
        
        # CPU CoStop
        $cpuCostopValues = $statsByMetric['cpu.costop.summation']
        $cpuCostopPercents = @()
        if ($cpuCostopValues) {
            $cpuCostopPercents = $cpuCostopValues | ForEach-Object { ($_.Value / 20000) * 100 }
        }
        
        # CPU Max Limited
        $cpuMaxLimitedValues = $statsByMetric['cpu.maxlimited.summation']
        $cpuMaxLimitedPercents = @()
        if ($cpuMaxLimitedValues) {
            $cpuMaxLimitedPercents = $cpuMaxLimitedValues | ForEach-Object { ($_.Value / 20000) * 100 }
        }
        
        # CPU Usage
        $cpuUsageValues = $statsByMetric['cpu.usage.average']
        $cpuUsageMhzValues = $statsByMetric['cpu.usagemhz.average']
        
        # NUMA metrics
        $numaLocalValues = $statsByMetric['numa.memoryLocal.average']
        $numaRemoteValues = $statsByMetric['numa.memoryRemote.average']
        
        # Calculate NUMA locality percentage for each sample
        $numaLocalityPercents = @()
        if ($numaLocalValues -and $numaRemoteValues) {
            for ($j = 0; $j -lt [math]::Min($numaLocalValues.Count, $numaRemoteValues.Count); $j++) {
                $local = $numaLocalValues[$j].Value
                $remote = $numaRemoteValues[$j].Value
                $total = $local + $remote
                if ($total -gt 0) {
                    $numaLocalityPercents += ($local / $total) * 100
                }
            }
        }
        
        # Helper function to calculate median
        function Get-Median {
            param($values)
            if (-not $values -or $values.Count -eq 0) { return 0 }
            $sorted = $values | Sort-Object
            $count = $sorted.Count
            if ($count % 2 -eq 0) {
                return ($sorted[$count/2 - 1] + $sorted[$count/2]) / 2
            } else {
                return $sorted[[math]::Floor($count/2)]
            }
        }
        
        # Calculate statistics
        $result = [PSCustomObject]@{
            VMName = $vm.Name
            Host = $vm.VMHost.Name
            NumCPUs = $vm.NumCpu
            MemoryGB = $vm.MemoryGB
            SampleCount = $vmStats.Count
            
            # CPU Ready
            CPUReadyAvg = if ($cpuReadyPercents.Count -gt 0) { [math]::Round(($cpuReadyPercents | Measure-Object -Average).Average, 2) } else { 0 }
            CPUReadyMedian = [math]::Round((Get-Median $cpuReadyPercents), 2)
            CPUReadyMax = if ($cpuReadyPercents.Count -gt 0) { [math]::Round(($cpuReadyPercents | Measure-Object -Maximum).Maximum, 2) } else { 0 }
            
            # CPU Wait
            CPUWaitAvg = if ($cpuWaitPercents.Count -gt 0) { [math]::Round(($cpuWaitPercents | Measure-Object -Average).Average, 2) } else { 0 }
            CPUWaitMedian = [math]::Round((Get-Median $cpuWaitPercents), 2)
            CPUWaitMax = if ($cpuWaitPercents.Count -gt 0) { [math]::Round(($cpuWaitPercents | Measure-Object -Maximum).Maximum, 2) } else { 0 }
            
            # CPU CoStop
            CPUCostopAvg = if ($cpuCostopPercents.Count -gt 0) { [math]::Round(($cpuCostopPercents | Measure-Object -Average).Average, 2) } else { 0 }
            CPUCostopMedian = [math]::Round((Get-Median $cpuCostopPercents), 2)
            CPUCostopMax = if ($cpuCostopPercents.Count -gt 0) { [math]::Round(($cpuCostopPercents | Measure-Object -Maximum).Maximum, 2) } else { 0 }
            
            # CPU Max Limited
            CPUMaxLimitedAvg = if ($cpuMaxLimitedPercents.Count -gt 0) { [math]::Round(($cpuMaxLimitedPercents | Measure-Object -Average).Average, 2) } else { 0 }
            CPUMaxLimitedMedian = [math]::Round((Get-Median $cpuMaxLimitedPercents), 2)
            
            # CPU Usage
            CPUUsageAvg = if ($cpuUsageValues) { [math]::Round(($cpuUsageValues.Value | Measure-Object -Average).Average, 2) } else { 0 }
            CPUUsageMedian = if ($cpuUsageValues) { [math]::Round((Get-Median $cpuUsageValues.Value), 2) } else { 0 }
            
            # NUMA Locality
            NUMALocalityAvg = if ($numaLocalityPercents.Count -gt 0) { [math]::Round(($numaLocalityPercents | Measure-Object -Average).Average, 2) } else { 0 }
            NUMALocalityMedian = [math]::Round((Get-Median $numaLocalityPercents), 2)
            NUMALocalityMin = if ($numaLocalityPercents.Count -gt 0) { [math]::Round(($numaLocalityPercents | Measure-Object -Minimum).Minimum, 2) } else { 0 }
            
            # Status
            ContentionStatus = if (($cpuReadyPercents | Measure-Object -Average).Average -gt 10) { "Critical" } 
                              elseif (($cpuReadyPercents | Measure-Object -Average).Average -gt 5) { "Warning" }
                              else { "Normal" }
        }
        
        [void]$results.Add($result)
    }
}

$stopwatch.Stop()
$elapsedTime = $stopwatch.Elapsed.TotalSeconds

Write-Host "`nCompleted in $([math]::Round($elapsedTime, 2)) seconds" -ForegroundColor Green
Write-Host "Processed $($results.Count) VMs successfully" -ForegroundColor Green

# Display top 20 by average CPU Ready
Write-Host "`n=== Top 20 VMs by Average CPU Ready (Contention) ===" -ForegroundColor Cyan
$results | Sort-Object CPUReadyAvg -Descending | Select-Object -First 20 | 
    Select-Object VMName, CPUReadyAvg, CPUReadyMedian, CPUReadyMax, CPUWaitAvg, NUMALocalityAvg |
    Format-Table -AutoSize

# Export full report
$exportPath = "VM_Metrics_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
$results | Export-Csv -Path $exportPath -NoTypeInformation
Write-Host "`nFull report exported to: $exportPath" -ForegroundColor Green

# Overall environment statistics
Write-Host "`n=== Environment-Wide Statistics (All VMs) ===" -ForegroundColor Green

$stats = [PSCustomObject]@{
    Metric = @(
        "CPU Ready %",
        "CPU Wait %", 
        "CPU CoStop %",
        "CPU Max Limited %",
        "CPU Usage %",
        "NUMA Locality %"
    )
    Average = @(
        [math]::Round(($results.CPUReadyAvg | Measure-Object -Average).Average, 2),
        [math]::Round(($results.CPUWaitAvg | Measure-Object -Average).Average, 2),
        [math]::Round(($results.CPUCostopAvg | Measure-Object -Average).Average, 2),
        [math]::Round(($results.CPUMaxLimitedAvg | Measure-Object -Average).Average, 2),
        [math]::Round(($results.CPUUsageAvg | Measure-Object -Average).Average, 2),
        [math]::Round(($results.NUMALocalityAvg | Where-Object {$_ -gt 0} | Measure-Object -Average).Average, 2)
    )
    Median = @(
        [math]::Round(($results.CPUReadyMedian | Measure-Object -Average).Average, 2),
        [math]::Round(($results.CPUWaitMedian | Measure-Object -Average).Average, 2),
        [math]::Round(($results.CPUCostopMedian | Measure-Object -Average).Average, 2),
        [math]::Round(($results.CPUMaxLimitedMedian | Measure-Object -Average).Average, 2),
        [math]::Round(($results.CPUUsageMedian | Measure-Object -Average).Average, 2),
        [math]::Round(($results.NUMALocalityMedian | Where-Object {$_ -gt 0} | Measure-Object -Average).Average, 2)
    )
}

$stats | Format-Table -AutoSize

# VM count by contention status
$criticalCount = ($results | Where-Object {$_.ContentionStatus -eq "Critical"}).Count
$warningCount = ($results | Where-Object {$_.ContentionStatus -eq "Warning"}).Count
$normalCount = ($results | Where-Object {$_.ContentionStatus -eq "Normal"}).Count

Write-Host "`n=== Contention Summary ===" -ForegroundColor Cyan
Write-Host "Critical (Avg CPU Ready >10%): $criticalCount VMs" -ForegroundColor Red
Write-Host "Warning (Avg CPU Ready 5-10%): $warningCount VMs" -ForegroundColor Yellow
Write-Host "Normal (Avg CPU Ready <5%):    $normalCount VMs" -ForegroundColor Green

# Show VMs with poor NUMA
$poorNUMAVMs = $results | Where-Object {$_.NUMALocalityAvg -gt 0 -and $_.NUMALocalityAvg -lt 80}
if ($poorNUMAVMs.Count -gt 0) {
    Write-Host "`n=== VMs with Poor NUMA Locality (Avg <80%) ===" -ForegroundColor Yellow
    $poorNUMAVMs | Sort-Object NUMALocalityAvg | Select-Object -First 10 |
        Select-Object VMName, NumCPUs, MemoryGB, NUMALocalityAvg, NUMALocalityMedian, NUMALocalityMin |
        Format-Table -AutoSize
} else {
    Write-Host "`nNo VMs with poor NUMA locality detected (or NUMA stats not available)" -ForegroundColor Green
}

Write-Host "`n=== Interpretation Guide ===" -ForegroundColor Cyan
Write-Host "CPU Ready % (time waiting for CPU):"
Write-Host "  <5%   = Good performance"
Write-Host "  5-10% = Moderate contention"  
Write-Host "  >10%  = Severe contention"
Write-Host "`nNUMA Locality % (local vs remote memory access):"
Write-Host "  >90%  = Excellent"
Write-Host "  80-90%= Good"
Write-Host "  <80%  = Poor (consider right-sizing or NUMA configuration)"
