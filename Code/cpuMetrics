# VM CPU Contention and NUMA Metrics - Diagnostic & Fixed Version
# Configuration
$BatchSize = 50
$HoursBack = 24  # Look back 24 hours (adjust if needed)

Write-Host "=== Starting VM Metrics Collection ===" -ForegroundColor Green
Write-Host "Looking back $HoursBack hours from now" -ForegroundColor Cyan

# Get powered-on VMs
Write-Host "`nStep 1: Getting VM inventory..." -ForegroundColor Cyan
$vms = Get-VM | Where-Object {$_.PowerState -eq "PoweredOn"}
Write-Host "Found $($vms.Count) powered-on VMs" -ForegroundColor Green

if ($vms.Count -eq 0) {
    Write-Host "ERROR: No powered-on VMs found!" -ForegroundColor Red
    exit
}

# Test with first 3 VMs to diagnose
Write-Host "`nStep 2: Testing stat collection with first 3 VMs..." -ForegroundColor Cyan
$testVMs = $vms | Select-Object -First 3
$startTime = (Get-Date).AddHours(-$HoursBack)

Write-Host "Start time: $startTime" -ForegroundColor Yellow
Write-Host "Test VMs: $($testVMs.Name -join ', ')" -ForegroundColor Yellow

# Try realtime stats first (most reliable)
Write-Host "`nTrying REALTIME stats..." -ForegroundColor Cyan
$realtimeStats = Get-Stat -Entity $testVMs -Realtime -MaxSamples 10 -ErrorAction SilentlyContinue

if ($realtimeStats) {
    Write-Host "SUCCESS: Realtime stats available!" -ForegroundColor Green
    Write-Host "Sample count: $($realtimeStats.Count)" -ForegroundColor Green
    Write-Host "Available metrics:" -ForegroundColor Yellow
    $realtimeStats | Select-Object -First 10 MetricId -Unique | ForEach-Object { Write-Host "  - $($_.MetricId)" }
} else {
    Write-Host "WARNING: No realtime stats returned" -ForegroundColor Yellow
}

# Try historical stats
Write-Host "`nTrying HISTORICAL stats (last $HoursBack hours)..." -ForegroundColor Cyan
$historicalStats = Get-Stat -Entity $testVMs -Start $startTime -ErrorAction SilentlyContinue

if ($historicalStats) {
    Write-Host "SUCCESS: Historical stats available!" -ForegroundColor Green
    Write-Host "Sample count: $($historicalStats.Count)" -ForegroundColor Green
    Write-Host "Available metrics:" -ForegroundColor Yellow
    $historicalStats | Select-Object MetricId -Unique | Select-Object -First 20 | ForEach-Object { Write-Host "  - $($_.MetricId)" }
} else {
    Write-Host "WARNING: No historical stats returned" -ForegroundColor Yellow
}

# Determine which method to use
$useRealtime = $false
if ($realtimeStats) {
    Write-Host "`nUsing REALTIME stats for collection" -ForegroundColor Green
    $useRealtime = $true
} elseif ($historicalStats) {
    Write-Host "`nUsing HISTORICAL stats for collection" -ForegroundColor Green
} else {
    Write-Host "`nERROR: No stats available! Check if:" -ForegroundColor Red
    Write-Host "  1. Statistics collection is enabled in vCenter" -ForegroundColor Red
    Write-Host "  2. You have proper permissions" -ForegroundColor Red
    Write-Host "  3. VMs have been running long enough" -ForegroundColor Red
    exit
}

# Now collect for all VMs
Write-Host "`nStep 3: Collecting stats for all $($vms.Count) VMs..." -ForegroundColor Cyan
$results = [System.Collections.ArrayList]::new()
$batches = [math]::Ceiling($vms.Count / $BatchSize)
$processedCount = 0

for ($i = 0; $i -lt $batches; $i++) {
    $batchStart = $i * $BatchSize
    $batchEnd = [math]::Min(($i + 1) * $BatchSize - 1, $vms.Count - 1)
    $currentBatch = $vms[$batchStart..$batchEnd]
    
    Write-Host "Processing batch $($i+1)/$batches (VMs $($batchStart+1)-$($batchEnd+1))..." -ForegroundColor Yellow
    
    # Get stats based on what works
    if ($useRealtime) {
        $allStats = Get-Stat -Entity $currentBatch -Realtime -MaxSamples 30 -ErrorAction SilentlyContinue
    } else {
        $allStats = Get-Stat -Entity $currentBatch -Start $startTime -ErrorAction SilentlyContinue
    }
    
    if (-not $allStats) {
        Write-Host "  No stats for this batch, skipping..." -ForegroundColor Gray
        continue
    }
    
    Write-Host "  Retrieved $($allStats.Count) stat samples" -ForegroundColor Gray
    
    # Group by VM for faster processing
    $statsByVM = $allStats | Group-Object -Property Entity
    
    foreach ($vm in $currentBatch) {
        $vmStats = ($statsByVM | Where-Object {$_.Name -eq $vm.Name}).Group
        
        if (-not $vmStats -or $vmStats.Count -eq 0) {
            continue
        }
        
        # Group by metric
        $byMetric = $vmStats | Group-Object -Property MetricId -AsHashTable
        
        # Helper function for stats calculation
        function Get-StatValues {
            param($metricData, $isDivision = $false)
            if (-not $metricData) { 
                return @{Avg=0; Median=0; Max=0; Count=0} 
            }
            $values = $metricData.Value
            if ($isDivision) {
                $values = $values | ForEach-Object { ($_ / 20000) * 100 }
            }
            $sorted = $values | Sort-Object
            $median = if ($sorted.Count -gt 0) {
                if ($sorted.Count % 2 -eq 0) {
                    ($sorted[$sorted.Count/2-1] + $sorted[$sorted.Count/2]) / 2
                } else {
                    $sorted[[math]::Floor($sorted.Count/2)]
                }
            } else { 0 }
            
            return @{
                Avg = if ($values) { ($values | Measure-Object -Average).Average } else { 0 }
                Median = $median
                Max = if ($values) { ($values | Measure-Object -Maximum).Maximum } else { 0 }
                Count = $values.Count
            }
        }
        
        # Get CPU metrics (these use summation, need division)
        $cpuReady = Get-StatValues $byMetric['cpu.ready.summation'] -isDivision $true
        $cpuWait = Get-StatValues $byMetric['cpu.wait.summation'] -isDivision $true
        $cpuCostop = Get-StatValues $byMetric['cpu.costop.summation'] -isDivision $true
        $cpuMaxLimited = Get-StatValues $byMetric['cpu.maxlimited.summation'] -isDivision $true
        
        # Get CPU usage (these are already percentages)
        $cpuUsage = Get-StatValues $byMetric['cpu.usage.average']
        $cpuUsageMhz = Get-StatValues $byMetric['cpu.usagemhz.average']
        
        # Get NUMA metrics and calculate locality
        $numaLocal = $byMetric['numa.memoryLocal.average']
        $numaRemote = $byMetric['numa.memoryRemote.average']
        
        $numaLocalityPercents = @()
        if ($numaLocal -and $numaRemote) {
            for ($j = 0; $j -lt [math]::Min($numaLocal.Count, $numaRemote.Count); $j++) {
                $local = $numaLocal[$j].Value
                $remote = $numaRemote[$j].Value
                $total = $local + $remote
                if ($total -gt 0) {
                    $numaLocalityPercents += ($local / $total) * 100
                }
            }
        }
        
        $numaLocality = Get-StatValues ($numaLocalityPercents | ForEach-Object { [PSCustomObject]@{Value=$_} })
        
        $result = [PSCustomObject]@{
            VMName = $vm.Name
            Host = $vm.VMHost.Name
            NumCPUs = $vm.NumCpu
            MemoryGB = $vm.MemoryGB
            Samples = $vmStats.Count
            
            CPUReady_Avg = [math]::Round($cpuReady.Avg, 2)
            CPUReady_Median = [math]::Round($cpuReady.Median, 2)
            CPUReady_Max = [math]::Round($cpuReady.Max, 2)
            
            CPUWait_Avg = [math]::Round($cpuWait.Avg, 2)
            CPUWait_Median = [math]::Round($cpuWait.Median, 2)
            CPUWait_Max = [math]::Round($cpuWait.Max, 2)
            
            CPUCoStop_Avg = [math]::Round($cpuCostop.Avg, 2)
            CPUCoStop_Median = [math]::Round($cpuCostop.Median, 2)
            CPUCoStop_Max = [math]::Round($cpuCostop.Max, 2)
            
            CPUMaxLimited_Avg = [math]::Round($cpuMaxLimited.Avg, 2)
            
            CPUUsage_Avg = [math]::Round($cpuUsage.Avg, 2)
            CPUUsage_Median = [math]::Round($cpuUsage.Median, 2)
            
            NUMALocality_Avg = [math]::Round($numaLocality.Avg, 2)
            NUMALocality_Median = [math]::Round($numaLocality.Median, 2)
            NUMALocality_Min = [math]::Round($numaLocality.Max, 2)
            
            Status = if ($cpuReady.Avg -gt 10) { "Critical" }
                    elseif ($cpuReady.Avg -gt 5) { "Warning" }
                    else { "Normal" }
        }
        
        [void]$results.Add($result)
        $processedCount++
    }
}

Write-Host "`nStep 4: Analysis complete!" -ForegroundColor Green
Write-Host "Successfully processed $processedCount VMs with data" -ForegroundColor Green

if ($results.Count -eq 0) {
    Write-Host "`nERROR: No VMs returned data. Possible issues:" -ForegroundColor Red
    Write-Host "  - Stats collection interval too short" -ForegroundColor Red
    Write-Host "  - VMs just started (no historical data)" -ForegroundColor Red
    Write-Host "  - vCenter statistics level too low" -ForegroundColor Red
    exit
}

# Display results
Write-Host "`n=== Top 20 VMs by CPU Ready (Contention) ===" -ForegroundColor Cyan
$results | Sort-Object CPUReady_Avg -Descending | Select-Object -First 20 |
    Format-Table VMName, CPUReady_Avg, CPUReady_Median, CPUWait_Avg, NUMALocality_Avg, Status -AutoSize

# Environment summary
Write-Host "`n=== Environment Summary (Average of VM Averages) ===" -ForegroundColor Green
[PSCustomObject]@{
    "CPU Ready %" = [math]::Round(($results.CPUReady_Avg | Measure-Object -Average).Average, 2)
    "CPU Ready Median %" = [math]::Round(($results.CPUReady_Median | Measure-Object -Average).Average, 2)
    "CPU Wait %" = [math]::Round(($results.CPUWait_Avg | Measure-Object -Average).Average, 2)
    "CPU CoStop %" = [math]::Round(($results.CPUCoStop_Avg | Measure-Object -Average).Average, 2)
    "CPU Usage %" = [math]::Round(($results.CPUUsage_Avg | Measure-Object -Average).Average, 2)
    "NUMA Locality %" = [math]::Round(($results | Where-Object {$_.NUMALocality_Avg -gt 0}).NUMALocality_Avg | Measure-Object -Average).Average, 2)
} | Format-List

# Status summary
$critical = ($results | Where-Object {$_.Status -eq "Critical"}).Count
$warning = ($results | Where-Object {$_.Status -eq "Warning"}).Count
$normal = ($results | Where-Object {$_.Status -eq "Normal"}).Count

Write-Host "=== VM Status Summary ===" -ForegroundColor Cyan
Write-Host "Critical (>10% CPU Ready): $critical" -ForegroundColor Red
Write-Host "Warning (5-10% CPU Ready): $warning" -ForegroundColor Yellow
Write-Host "Normal (<5% CPU Ready):    $normal" -ForegroundColor Green

# Export
$exportPath = "VM_Metrics_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
$results | Export-Csv -Path $exportPath -NoTypeInformation
Write-Host "`nFull report: $exportPath" -ForegroundColor Green
