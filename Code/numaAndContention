[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [switch]$TestConnection
)

# Configuration - Modify these values
$vCenterServers = @("vcenter01.domain.com", "vcenter02.domain.com")
$SDDCServer = "sddc01.domain.com"
$KeyDirectory = "./keys"

# Configuration
$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

# Initialize logging
$LogFile = "ESXi-KeyDeployment-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogMessage = "[$Timestamp] [$Level] $Message"
    Write-Host $LogMessage
    Add-Content -Path $LogFile -Value $LogMessage
}

#region SSH Key Generation
function New-RSAKeyPair {
    param(
        [string]$KeyPath,
        [int]$KeySize = 4096
    )
    
    Write-Log "Generating RSA $KeySize-bit SSH key pair..."
    
    # Ensure directory exists
    $KeyDir = Split-Path -Parent $KeyPath
    if (!(Test-Path $KeyDir)) {
        New-Item -ItemType Directory -Path $KeyDir -Force | Out-Null
    }
    
    # Generate key using ssh-keygen (cross-platform in PS7)
    $PrivateKeyPath = "$KeyPath"
    $PublicKeyPath = "$KeyPath.pub"
    
    # Check if ssh-keygen is available
    if (!(Get-Command ssh-keygen -ErrorAction SilentlyContinue)) {
        throw "ssh-keygen not found. Please install OpenSSH client."
    }
    
    # Generate key (no passphrase for automation)
    $sshKeyGenArgs = @(
        "-t", "rsa",
        "-b", $KeySize,
        "-f", $PrivateKeyPath,
        "-N", '""',
        "-C", "esxi-automation-$(Get-Date -Format 'yyyyMMdd')"
    )
    
    & ssh-keygen @sshKeyGenArgs 2>&1 | Out-Null
    
    if (!(Test-Path $PrivateKeyPath) -or !(Test-Path $PublicKeyPath)) {
        throw "Failed to generate SSH key pair"
    }
    
    Write-Log "SSH key pair generated successfully at $KeyDir" -Level "SUCCESS"
    
    return @{
        PrivateKey = $PrivateKeyPath
        PublicKey = $PublicKeyPath
        PublicKeyContent = Get-Content $PublicKeyPath -Raw
    }
}
#endregion

#region SDDC API Authentication
function Get-SDDCApiToken {
    param(
        [string]$Server,
        [PSCredential]$Credential
    )
    
    Write-Log "Authenticating with SDDC API to obtain token..."
    
    try {
        $AuthEndpoint = "https://$Server/v1/tokens"
        
        # Create basic auth header
        $Base64Auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$($Credential.UserName):$($Credential.GetNetworkCredential().Password)"))
        
        $Headers = @{
            "Authorization" = "Basic $Base64Auth"
            "Content-Type" = "application/json"
        }
        
        $Response = Invoke-RestMethod -Uri $AuthEndpoint -Method Post -Headers $Headers
        
        Write-Log "SDDC API token obtained successfully" -Level "SUCCESS"
        return $Response.accessToken
    }
    catch {
        Write-Log "Failed to obtain SDDC API token: $_" -Level "ERROR"
        throw
    }
}
#endregion

#region ESXi Credentials Discovery
function Get-ESXiCredentialsFromSDDC {
    param(
        [string]$Server,
        [string]$Token
    )
    
    Write-Log "Retrieving ESXi credentials from SDDC API..."
    
    try {
        # Query credentials endpoint with ESXi resource type filter
        $CredentialsEndpoint = "https://$Server/v1/credentials?resourceType=ESXI"
        
        $Headers = @{
            "Authorization" = "Bearer $Token"
            "Content-Type" = "application/json"
        }
        
        $Response = Invoke-RestMethod -Uri $CredentialsEndpoint -Method Get -Headers $Headers
        
        # Filter for root accounts only
        $RootCredentials = $Response.elements | Where-Object {
            $_.accountType -eq "USER" -and $_.username -eq "root"
        }
        
        if ($RootCredentials.Count -eq 0) {
            Write-Log "No root credentials found for ESXi hosts" -Level "WARN"
            return @()
        }
        
        # Parse and format credentials
        $ESXiHosts = $RootCredentials | ForEach-Object {
            [PSCustomObject]@{
                ResourceName = $_.resourceName
                AccountType = $_.accountType
                Username = $_.username
                Password = $_.password
                CredentialType = $_.credentialType
            }
        }
        
        Write-Log "Retrieved $($ESXiHosts.Count) ESXi root credentials" -Level "SUCCESS"
        return $ESXiHosts
    }
    catch {
        Write-Log "Failed to retrieve ESXi credentials: $_" -Level "ERROR"
        throw
    }
}
#endregion

#region SSH Key Deployment
function Deploy-SSHKeyToESXi {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ESXiHost,
        
        [Parameter(Mandatory=$true)]
        [PSCredential]$Credential,
        
        [Parameter(Mandatory=$true)]
        [string]$PublicKey
    )
    
    Write-Log "Deploying SSH key to $ESXiHost..."
    
    try {
        # Connect via SSH using Posh-SSH module (install if needed)
        if (!(Get-Module -ListAvailable -Name Posh-SSH)) {
            Write-Log "Installing Posh-SSH module..." -Level "WARN"
            Install-Module -Name Posh-SSH -Force -Scope CurrentUser
        }
        
        Import-Module Posh-SSH -ErrorAction Stop
        
        # Establish SSH session
        $Session = New-SSHSession -ComputerName $ESXiHost -Credential $Credential -AcceptKey
        
        if (!$Session) {
            throw "Failed to establish SSH session"
        }
        
        # Prepare authorized_keys directory
        $Commands = @(
            "mkdir -p /etc/ssh/keys-root",
            "chmod 700 /etc/ssh/keys-root",
            "touch /etc/ssh/keys-root/authorized_keys",
            "chmod 600 /etc/ssh/keys-root/authorized_keys"
        )
        
        foreach ($Cmd in $Commands) {
            Invoke-SSHCommand -SessionId $Session.SessionId -Command $Cmd | Out-Null
        }
        
        # Check if key already exists
        $CheckKey = Invoke-SSHCommand -SessionId $Session.SessionId -Command "grep -F `"$PublicKey`" /etc/ssh/keys-root/authorized_keys"
        
        if ($CheckKey.Output) {
            Write-Log "Public key already exists on $ESXiHost" -Level "WARN"
        }
        else {
            # Append public key
            $EscapedKey = $PublicKey.Replace('"', '\"')
            $AddKeyCmd = "echo `"$EscapedKey`" >> /etc/ssh/keys-root/authorized_keys"
            Invoke-SSHCommand -SessionId $Session.SessionId -Command $AddKeyCmd | Out-Null
            
            Write-Log "SSH key deployed to $ESXiHost successfully" -Level "SUCCESS"
        }
        
        # Persist configuration across reboots
        Invoke-SSHCommand -SessionId $Session.SessionId -Command "/sbin/auto-backup.sh" | Out-Null
        
        # Close session
        Remove-SSHSession -SessionId $Session.SessionId | Out-Null
        
        return $true
    }
    catch {
        Write-Log "Failed to deploy key to $ESXiHost : $_" -Level "ERROR"
        return $false
    }
}
#endregion

#region Main Execution
try {
    Write-Log "=== ESXi SSH Key Deployment Automation Started ===" -Level "INFO"
    
    # Get credentials (same for both vCenter and SDDC)
    $Credential = Get-Credential -Message "Enter vCenter/SDDC credentials"
    
    # Step 1: Connect to all vCenter servers
    Write-Log "Connecting to vCenter servers..."
    
    $ConnectedvCenters = @()
    foreach ($vCenter in $vCenterServers) {
        try {
            $Connection = Connect-VIServer -Server $vCenter -Credential $Credential -ErrorAction Stop
            Write-Log "Connected to vCenter: $vCenter" -Level "SUCCESS"
            $ConnectedvCenters += $vCenter
        }
        catch {
            Write-Log "Failed to connect to $vCenter : $_" -Level "ERROR"
        }
    }
    
    if ($ConnectedvCenters.Count -eq 0) {
        throw "Failed to connect to any vCenter servers"
    }
    
    Write-Log "Successfully connected to $($ConnectedvCenters.Count) of $($vCenterServers.Count) vCenter(s)" -Level "SUCCESS"
    
    # Step 2: Authenticate with SDDC API and get token
    $ApiToken = Get-SDDCApiToken -Server $SDDCServer -Credential $Credential
    
    # Step 3: Generate SSH key pair
    $KeyPath = Join-Path $KeyDirectory "esxi_key"
    $KeyPair = New-RSAKeyPair -KeyPath $KeyPath -KeySize 4096
    
    Write-Log "Private Key: $($KeyPair.PrivateKey)"
    Write-Log "Public Key: $($KeyPair.PublicKey)"
    
    # Step 4: Retrieve ESXi credentials from SDDC API
    $ESXiHosts = Get-ESXiCredentialsFromSDDC -Server $SDDCServer -Token $ApiToken
    
    if ($ESXiHosts.Count -eq 0) {
        Write-Log "No ESXi hosts found" -Level "WARN"
        exit 0
    }
    
    # Step 5: Deploy SSH key to each host
    $Results = @()
    foreach ($ESXiHost in $ESXiHosts) {
        $HostCred = New-Object System.Management.Automation.PSCredential(
            $ESXiHost.Username,
            (ConvertTo-SecureString $ESXiHost.Password -AsPlainText -Force)
        )
        
        $Success = Deploy-SSHKeyToESXi -ESXiHost $ESXiHost.ResourceName -Credential $HostCred -PublicKey $KeyPair.PublicKeyContent.Trim()
        
        $Results += [PSCustomObject]@{
            ResourceName = $ESXiHost.ResourceName
            AccountType = $ESXiHost.AccountType
            Username = $ESXiHost.Username
            Status = if ($Success) { "SUCCESS" } else { "FAILED" }
            Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        }
    }
    
    # Step 6: Generate report
    Write-Log "`n=== Deployment Summary ===" -Level "INFO"
    $Results | Format-Table -AutoSize
    
    $ReportPath = "ESXi-KeyDeployment-Report-$(Get-Date -Format 'yyyyMMdd-HHmmss').csv"
    $Results | Export-Csv -Path $ReportPath -NoTypeInformation
    Write-Log "Report saved to: $ReportPath" -Level "SUCCESS"
    
    # Optional: Test key-based authentication
    if ($TestConnection) {
        Write-Log "`n=== Testing SSH Key Authentication ===" -Level "INFO"
        foreach ($ESXiHost in $ESXiHosts | Select-Object -First 1) {
            Write-Log "Testing connection to $($ESXiHost.ResourceName)..."
            # Implementation for testing key auth would go here
        }
    }
}
catch {
    Write-Log "Critical error: $_" -Level "ERROR"
    throw
}
finally {
    # Disconnect from all vCenter servers
    if ($global:DefaultVIServers) {
        Disconnect-VIServer -Server * -Confirm:$false -ErrorAction SilentlyContinue
        Write-Log "Disconnected from all vCenter servers" -Level "INFO"
    }
    
    Write-Log "=== Script execution completed ===" -Level "INFO"
}
#endregion
