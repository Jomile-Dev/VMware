[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [switch]$TestConnection
)

# Configuration - Modify these values
$vCenterServers = @("vcenter01.domain.com", "vcenter02.domain.com")
$SddcManagerUrl = "https://sddc01.domain.com"  # Must include https://
$KeyDirectory = "./keys"
$HostFilter = "W03"  # Only process hosts containing this string

# Configuration
$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

# Initialize logging
$LogFile = "ESXi-KeyDeployment-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogMessage = "[$Timestamp] [$Level] $Message"
    Write-Host $LogMessage
    Add-Content -Path $LogFile -Value $LogMessage
}

#region SSH Key Generation
function New-RSAKeyPair {
    param(
        [string]$KeyPath,
        [int]$KeySize = 4096
    )
    
    Write-Log "Generating RSA $KeySize-bit SSH key pair..."
    
    # Ensure directory exists
    $KeyDir = Split-Path -Parent $KeyPath
    if (!(Test-Path $KeyDir)) {
        New-Item -ItemType Directory -Path $KeyDir -Force | Out-Null
    }
    
    # Generate key using ssh-keygen (cross-platform in PS7)
    $PrivateKeyPath = "$KeyPath"
    $PublicKeyPath = "$KeyPath.pub"
    
    # Check if ssh-keygen is available
    if (!(Get-Command ssh-keygen -ErrorAction SilentlyContinue)) {
        throw "ssh-keygen not found. Please install OpenSSH client."
    }
    
    # Generate key (no passphrase for automation)
    $sshKeyGenArgs = @(
        "-t", "rsa",
        "-b", $KeySize,
        "-f", $PrivateKeyPath,
        "-N", '""',
        "-C", "esxi-automation-$(Get-Date -Format 'yyyyMMdd')"
    )
    
    & ssh-keygen @sshKeyGenArgs 2>&1 | Out-Null
    
    if (!(Test-Path $PrivateKeyPath) -or !(Test-Path $PublicKeyPath)) {
        throw "Failed to generate SSH key pair"
    }
    
    Write-Log "SSH key pair generated successfully at $KeyDir" -Level "SUCCESS"
    
    return @{
        PrivateKey = $PrivateKeyPath
        PublicKey = $PublicKeyPath
        PublicKeyContent = Get-Content $PublicKeyPath -Raw
    }
}
#endregion

#region SDDC API Authentication
function Get-ApiToken {
    param(
        [string]$SddcManagerUrl,
        [PSCredential]$Credential
    )
    
    Write-Log "Generating API Token using JSON body..."
    
    # Ensure URL has https:// prefix
    if ($SddcManagerUrl -notmatch '^https?://') {
        $SddcManagerUrl = "https://$SddcManagerUrl"
        Write-Log "Added https:// prefix to SDDC Manager URL" -Level "WARN"
    }
    
    # Remove trailing slash if present
    $SddcManagerUrl = $SddcManagerUrl.TrimEnd('/')
    
    try {
        $username = $Credential.UserName
        $password = $Credential.GetNetworkCredential().Password
        
        $body = @{ username = $username; password = $password } | ConvertTo-Json
        $headers = @{ "Content-Type" = "application/json" }
        
        $tokenUri = "$SddcManagerUrl/v1/tokens"
        Write-Log "Requesting token from: $tokenUri"
        
        $response = Invoke-RestMethod -Uri $tokenUri -Method Post -Headers $headers -Body $body -SkipCertificateCheck
        
        Write-Log "API Token generated successfully" -Level "SUCCESS"
        return $response.accessToken
    }
    catch {
        Write-Log "Failed to generate API token: $_" -Level "ERROR"
        throw
    }
}
#endregion

#region ESXi Credentials Discovery
function Get-ESXiCredentials {
    param(
        [string]$SddcManagerUrl,
        [string]$apiToken,
        [string]$HostFilter = ""
    )
    
    Write-Log "Getting ESXi credentials from SDDC Manager API..."
    
    # Ensure URL has https:// prefix and no trailing slash
    if ($SddcManagerUrl -notmatch '^https?://') {
        $SddcManagerUrl = "https://$SddcManagerUrl"
    }
    $SddcManagerUrl = $SddcManagerUrl.TrimEnd('/')
    
    try {
        $headers = @{
            "Authorization" = "Bearer $apiToken"
            "Content-Type" = "application/json"
        }
        
        $uri = "$SddcManagerUrl/v1/credentials?resourceType=ESXI"
        Write-Log "Requesting credentials from: $uri"
        
        $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get -SkipCertificateCheck
        $credentials = $response.elements
        
        if (-not $credentials) {
            Write-Log "No credentials found under 'elements'." -Level "WARN"
            return @()
        }
        
        # Print available account types and usernames
        Write-Host "`nAvailable ESXi Credentials:"
        $credentials | ForEach-Object {
            [PSCustomObject]@{
                ResourceName = $_.resource.resourceName
                AccountType = $_.accountType
                Username = $_.username
                CredentialType = $_.credentialType
                HasPassword = if ($_.password) { "Yes" } else { "No" }
            }
        } | Format-Table -AutoSize
        
        # Filter for SSH credentials with username 'root'
        $filtered = $credentials | Where-Object {
            $_.credentialType -eq "SSH" -and $_.username -eq "root"
        } | ForEach-Object {
            # Check if password exists
            if (-not $_.password) {
                Write-Log "Warning: No password found for $($_.resource.resourceName)" -Level "WARN"
            }
            
            [PSCustomObject]@{
                ResourceName = $_.resource.resourceName
                AccountType = $_.accountType
                Username = $_.username
                Password = $_.password
                CredentialType = $_.credentialType
            }
        }
        
        # Remove entries with null passwords
        $filtered = $filtered | Where-Object { $_.Password -ne $null -and $_.Password -ne "" }
        
        if ($filtered.Count -eq 0) {
            Write-Log "No SSH root credentials with valid passwords found for ESXi hosts" -Level "WARN"
            return @()
        }
        
        Write-Log "Found $($filtered.Count) ESXi root SSH credentials with valid passwords" -Level "SUCCESS"
        
        # Filter for hosts containing the specified filter string
        if ($HostFilter) {
            Write-Host "`nFiltering for hosts containing '$HostFilter'..."
            $filteredByName = $filtered | Where-Object {
                $_.ResourceName -like "*$HostFilter*"
            }
            
            if ($filteredByName.Count -eq 0) {
                Write-Log "No hosts found matching filter '$HostFilter'" -Level "WARN"
                return @()
            }
            
            Write-Log "Found $($filteredByName.Count) hosts matching filter '$HostFilter'" -Level "SUCCESS"
            return $filteredByName
        }
        
        return $filtered
    }
    catch {
        Write-Log "Failed to retrieve ESXi credentials: $_" -Level "ERROR"
        throw
    }
}
#endregion

#region Enable SSH on ESXi
function Enable-SSH {
    param(
        [Parameter(Mandatory=$true)]
        [ValidateNotNullOrEmpty()]
        [string]$esxiHost
    )
    
    Write-Log "Attempting to enable SSH on: $esxiHost"
    
    try {
        # Get the VMHost object first
        $vmHost = Get-VMHost -Name $esxiHost -ErrorAction Stop
        
        if (-not $vmHost) {
            throw "Host $esxiHost not found in connected vCenter(s)"
        }
        
        Write-Log "Found host: $($vmHost.Name) (State: $($vmHost.ConnectionState))"
        
        # Get SSH service and check if it's already running
        $sshService = Get-VMHostService -VMHost $vmHost | Where-Object { $_.Key -eq "TSM-SSH" }
        
        if (-not $sshService) {
            throw "SSH service (TSM-SSH) not found on host"
        }
        
        if ($sshService.Running) {
            Write-Log "SSH service is already running on $esxiHost" -Level "INFO"
        }
        else {
            Write-Log "Starting SSH service on $esxiHost..."
            Start-VMHostService -HostService $sshService -Confirm:$false | Out-Null
            Write-Log "SSH service started on $esxiHost" -Level "SUCCESS"
        }
        
        return $true
    }
    catch {
        Write-Log "Error enabling SSH on ${esxiHost}: $_" -Level "ERROR"
        return $false
    }
}
#endregion

#region Deploy SSH Key and Clean Old Keys
function Deploy-SSHKeyToESXi {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ESXiHost,
        
        [Parameter(Mandatory=$true)]
        [PSCredential]$Credential,
        
        [Parameter(Mandatory=$true)]
        [string]$PublicKey
    )
    
    Write-Log "Deploying SSH key to $ESXiHost..."
    
    try {
        # Connect via SSH using Posh-SSH module (install if needed)
        if (!(Get-Module -ListAvailable -Name Posh-SSH)) {
            Write-Log "Installing Posh-SSH module..." -Level "WARN"
            Install-Module -Name Posh-SSH -Force -Scope CurrentUser
        }
        
        Import-Module Posh-SSH -ErrorAction Stop
        
        # Establish SSH session
        $Session = New-SSHSession -ComputerName $ESXiHost -Credential $Credential -AcceptKey -ErrorAction Stop
        
        if (!$Session) {
            throw "Failed to establish SSH session"
        }
        
        # Prepare authorized_keys directory
        $Commands = @(
            "mkdir -p /etc/ssh/keys-root",
            "chmod 700 /etc/ssh/keys-root",
            "touch /etc/ssh/keys-root/authorized_keys",
            "chmod 600 /etc/ssh/keys-root/authorized_keys"
        )
        
        foreach ($Cmd in $Commands) {
            Invoke-SSHCommand -SessionId $Session.SessionId -Command $Cmd -ErrorAction SilentlyContinue | Out-Null
        }
        
        # Remove old SSH keys ending with '110'
        Write-Log "Removing old SSH keys ending with '110' from $ESXiHost..."
        $RemoveOldKeysCmd = "sed -i '/110$/d' /etc/ssh/keys-root/authorized_keys"
        $RemoveResult = Invoke-SSHCommand -SessionId $Session.SessionId -Command $RemoveOldKeysCmd
        
        if ($RemoveResult.ExitStatus -eq 0) {
            Write-Log "Old SSH keys removed successfully" -Level "SUCCESS"
        }
        else {
            Write-Log "No old keys found or removal had issues" -Level "WARN"
        }
        
        # Check if new key already exists
        $CheckKey = Invoke-SSHCommand -SessionId $Session.SessionId -Command "grep -F `"$PublicKey`" /etc/ssh/keys-root/authorized_keys"
        
        if ($CheckKey.Output) {
            Write-Log "Public key already exists on $ESXiHost" -Level "WARN"
        }
        else {
            # Append public key
            $EscapedKey = $PublicKey.Replace('"', '\"').Replace('$', '\$')
            $AddKeyCmd = "echo `"$EscapedKey`" >> /etc/ssh/keys-root/authorized_keys"
            $AddResult = Invoke-SSHCommand -SessionId $Session.SessionId -Command $AddKeyCmd
            
            if ($AddResult.ExitStatus -eq 0) {
                Write-Log "SSH key deployed to $ESXiHost successfully" -Level "SUCCESS"
            }
            else {
                throw "Failed to add SSH key: $($AddResult.Error)"
            }
        }
        
        # Persist configuration across reboots
        Invoke-SSHCommand -SessionId $Session.SessionId -Command "/sbin/auto-backup.sh" -ErrorAction SilentlyContinue | Out-Null
        
        # Close session
        Remove-SSHSession -SessionId $Session.SessionId | Out-Null
        
        return $true
    }
    catch {
        Write-Log "Failed to deploy key to $ESXiHost : $_" -Level "ERROR"
        if ($Session) {
            Remove-SSHSession -SessionId $Session.SessionId -ErrorAction SilentlyContinue | Out-Null
        }
        return $false
    }
}
#endregion

#region Capture ESXtop Performance Data
function Get-ESXtopPerformanceData {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ESXiHost,
        
        [Parameter(Mandatory=$true)]
        [PSCredential]$Credential
    )
    
    Write-Log "Capturing ESXtop performance data from $ESXiHost..."
    
    try {
        Import-Module Posh-SSH -ErrorAction Stop
        
        # Establish SSH session
        $Session = New-SSHSession -ComputerName $ESXiHost -Credential $Credential -AcceptKey -ErrorAction Stop
        
        if (!$Session) {
            throw "Failed to establish SSH session for performance data capture"
        }
        
        # Run esxtop in batch mode to capture VM CPU statistics
        # -b = batch mode, -n 1 = one iteration, -c = CPU view
        Write-Log "Running esxtop to capture CPU metrics..."
        $EsxtopCmd = "esxtop -b -n 1 -c | head -n 50"
        $EsxtopResult = Invoke-SSHCommand -SessionId $Session.SessionId -Command $EsxtopCmd -TimeOut 30
        
        # Parse the output for VM-specific metrics
        $OutputLines = $EsxtopResult.Output -split "`n"
        
        # Create a structured output
        $PerformanceData = @{
            Host = $ESXiHost
            Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            RawData = $EsxtopResult.Output
        }
        
        # Alternative: Get specific VM performance metrics using vim-cmd
        Write-Log "Getting VM list and performance metrics..."
        $VMListCmd = "vim-cmd vmsvc/getallvms | grep -v '^Vmid' | awk '{print `$1, `$2}'"
        $VMListResult = Invoke-SSHCommand -SessionId $Session.SessionId -Command $VMListCmd
        
        # Get CPU ready and co-stop values for each VM
        Write-Log "Collecting detailed VM CPU metrics..."
        $VMMetrics = @()
        
        # Use esxcli to get VM world IDs and then query performance
        $WorldCmd = "esxcli vm process list"
        $WorldResult = Invoke-SSHCommand -SessionId $Session.SessionId -Command $WorldCmd
        
        # Parse world data
        $CurrentVM = $null
        $WorldLines = $WorldResult.Output -split "`n"
        foreach ($Line in $WorldLines) {
            if ($Line -match "^(\S+):$") {
                $CurrentVM = $Matches[1]
            }
            elseif ($Line -match "World ID:\s+(\d+)" -and $CurrentVM) {
                $WorldID = $Matches[1]
                
                # Get CPU stats for this world
                $StatsCmd = "vsish -e get /sched/groups/$WorldID/stats"
                $StatsResult = Invoke-SSHCommand -SessionId $Session.SessionId -Command $StatsCmd -ErrorAction SilentlyContinue
                
                if ($StatsResult.ExitStatus -eq 0) {
                    $VMMetrics += [PSCustomObject]@{
                        VMName = $CurrentVM
                        WorldID = $WorldID
                        Stats = $StatsResult.Output
                    }
                }
            }
        }
        
        $PerformanceData.VMMetrics = $VMMetrics
        
        # Alternative method using esxtop interactive mode simulation
        Write-Log "Getting CPU contention metrics..."
        
        # Run a more targeted esxtop command for CPU stats
        $CPUStatsCmd = @"
echo -e "c\nV\nq" | esxtop -b -n 1 | grep -E "^\s*(Group|VM|vmx-)" | head -n 30
"@
        $CPUStatsResult = Invoke-SSHCommand -SessionId $Session.SessionId -Command $CPUStatsCmd -TimeOut 30
        $PerformanceData.CPUContention = $CPUStatsResult.Output
        
        # Close session
        Remove-SSHSession -SessionId $Session.SessionId | Out-Null
        
        return $PerformanceData
    }
    catch {
        Write-Log "Failed to capture performance data from $ESXiHost : $_" -Level "ERROR"
        if ($Session) {
            Remove-SSHSession -SessionId $Session.SessionId -ErrorAction SilentlyContinue | Out-Null
        }
        return $null
    }
}
#endregion

#region Main Execution
try {
    Write-Log "=== ESXi SSH Key Deployment Automation Started ===" -Level "INFO"
    
    # Get credentials (same for both vCenter and SDDC)
    $Credential = Get-Credential -Message "Enter vCenter/SDDC credentials"
    
    # Step 1: Connect to all vCenter servers
    Write-Log "Connecting to vCenter servers..."
    
    $ConnectedvCenters = @()
    foreach ($vCenter in $vCenterServers) {
        try {
            $Connection = Connect-VIServer -Server $vCenter -Credential $Credential -ErrorAction Stop
            Write-Log "Connected to vCenter: $vCenter" -Level "SUCCESS"
            $ConnectedvCenters += $vCenter
        }
        catch {
            Write-Log "Failed to connect to $vCenter : $_" -Level "ERROR"
        }
    }
    
    if ($ConnectedvCenters.Count -eq 0) {
        throw "Failed to connect to any vCenter servers"
    }
    
    Write-Log "Successfully connected to $($ConnectedvCenters.Count) of $($vCenterServers.Count) vCenter(s)" -Level "SUCCESS"
    
    # Step 2: Generate SSH Keys
    $KeyPath = Join-Path $KeyDirectory "esxi_key"
    $KeyPair = New-RSAKeyPair -KeyPath $KeyPath -KeySize 4096
    
    Write-Log "Private Key: $($KeyPair.PrivateKey)"
    Write-Log "Public Key: $($KeyPair.PublicKey)"
    
    # Step 3: Authenticate with SDDC Manager and get API token
    $ApiToken = Get-ApiToken -SddcManagerUrl $SddcManagerUrl -Credential $Credential
    
    # Step 4: Retrieve ESXi root credentials from SDDC Manager (filtered for W03 hosts)
    $ESXiHosts = Get-ESXiCredentials -SddcManagerUrl $SddcManagerUrl -apiToken $ApiToken -HostFilter $HostFilter
    
    if ($ESXiHosts.Count -eq 0) {
        Write-Log "No ESXi hosts found matching filter criteria" -Level "WARN"
        exit 0
    }
    
    Write-Host "`nFiltered ESXi Hosts to Process:"
    $ESXiHosts | Format-Table -AutoSize
    
    # Step 5: Enable SSH on filtered ESXi hosts
    Write-Log "`n=== Enabling SSH on ESXi hosts via vSphere ===" -Level "INFO"
    
    $SSHEnabledHosts = @()
    foreach ($ESXiHost in $ESXiHosts) {
        $esxiHostName = $ESXiHost.ResourceName
        
        # Check if host name is valid
        if ([string]::IsNullOrWhiteSpace($esxiHostName)) {
            Write-Log "Skipping host with empty name" -Level "WARN"
            continue
        }
        
        $sshEnabled = Enable-SSH -esxiHost $esxiHostName
        if ($sshEnabled) {
            $SSHEnabledHosts += $ESXiHost
            Write-Log "SSH enabled on $esxiHostName" -Level "SUCCESS"
        }
        else {
            Write-Log "Failed to enable SSH on $esxiHostName" -Level "ERROR"
        }
    }
    
    # Give SSH service time to start
    if ($SSHEnabledHosts.Count -gt 0) {
        Write-Log "Waiting for SSH services to start..."
        Start-Sleep -Seconds 5
    }
    else {
        Write-Log "No hosts with SSH enabled. Exiting." -Level "ERROR"
        exit 1
    }
    
    # Step 6: Deploy SSH key to each host
    Write-Log "`n=== Deploying SSH Keys ===" -Level "INFO"
    $Results = @()
    $PerformanceResults = @()
    
    foreach ($ESXiHost in $SSHEnabledHosts) {
        # Validate password exists before creating credential
        if ([string]::IsNullOrEmpty($ESXiHost.Password)) {
            Write-Log "Skipping $($ESXiHost.ResourceName) - No password available for SSH key deployment" -Level "WARN"
            $Results += [PSCustomObject]@{
                ResourceName = $ESXiHost.ResourceName
                AccountType = $ESXiHost.AccountType
                Username = $ESXiHost.Username
                Status = "SKIPPED - No Password"
                Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            }
            continue
        }
        
        $HostCred = New-Object System.Management.Automation.PSCredential(
            $ESXiHost.Username,
            (ConvertTo-SecureString $ESXiHost.Password -AsPlainText -Force)
        )
        
        # Deploy SSH key and remove old keys
        $Success = Deploy-SSHKeyToESXi -ESXiHost $ESXiHost.ResourceName -Credential $HostCred -PublicKey $KeyPair.PublicKeyContent.Trim()
        
        $Results += [PSCustomObject]@{
            ResourceName = $ESXiHost.ResourceName
            AccountType = $ESXiHost.AccountType
            Username = $ESXiHost.Username
            Status = if ($Success) { "SUCCESS" } else { "FAILED" }
            Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        }
        
        # If key deployment was successful, capture performance data
        if ($Success) {
            Write-Log "`n=== Capturing Performance Data from $($ESXiHost.ResourceName) ===" -Level "INFO"
            $PerfData = Get-ESXtopPerformanceData -ESXiHost $ESXiHost.ResourceName -Credential $HostCred
            
            if ($PerfData) {
                $PerformanceResults += $PerfData
                
                # Save performance data to individual file
                $PerfFile = "ESXi-Performance-$($ESXiHost.ResourceName)-$(Get-Date -Format 'yyyyMMdd-HHmmss').txt"
                $PerfData | ConvertTo-Json -Depth 5 | Out-File -FilePath $PerfFile
                Write-Log "Performance data saved to: $PerfFile" -Level "SUCCESS"
                
                # Display summary of CPU contention data
                Write-Host "`nCPU Contention Data for $($ESXiHost.ResourceName):"
                Write-Host $PerfData.CPUContention
            }
        }
    }
    
    # Step 7: Generate reports
    Write-Log "`n=== Deployment Summary ===" -Level "INFO"
    $Results | Format-Table -AutoSize
    
    $ReportPath = "ESXi-KeyDeployment-Report-$(Get-Date -Format 'yyyyMMdd-HHmmss').csv"
    $Results | Export-Csv -Path $ReportPath -NoTypeInformation
    Write-Log "Deployment report saved to: $ReportPath" -Level "SUCCESS"
    
    # Save consolidated performance report
    if ($PerformanceResults.Count -gt 0) {
        $PerfReportPath = "ESXi-Performance-Report-$(Get-Date -Format 'yyyyMMdd-HHmmss').json"
        $PerformanceResults | ConvertTo-Json -Depth 5 | Out-File -FilePath $PerfReportPath
        Write-Log "Performance report saved to: $PerfReportPath" -Level "SUCCESS"
    }
    
    # Optional: Test key-based authentication
    if ($TestConnection) {
        Write-Log "`n=== Testing SSH Key Authentication ===" -Level "INFO"
        foreach ($ESXiHost in $SSHEnabledHosts | Select-Object -First 1) {
            Write-Log "Testing connection to $($ESXiHost.ResourceName)..."
            
            try {
                # Test with key authentication
                $TestSession = New-SSHSession -ComputerName $ESXiHost.ResourceName -KeyFile $KeyPair.PrivateKey -ErrorAction Stop
                if ($TestSession) {
                    Write-Log "Key-based authentication successful for $($ESXiHost.ResourceName)" -Level "SUCCESS"
                    Remove-SSHSession -SessionId $TestSession.SessionId | Out-Null
                }
            }
            catch {
                Write-Log "Key-based authentication test failed: $_" -Level "WARN"
            }
        }
    }
}
catch {
    Write-Log "Critical error: $_" -Level "ERROR"
    throw
}
finally {
    # Disconnect from all vCenter servers
    if ($global:DefaultVIServers) {
        Disconnect-VIServer -Server * -Confirm:$false -ErrorAction SilentlyContinue
        Write-Log "Disconnected from all vCenter servers" -Level "INFO"
    }
    
    Write-Log "=== Script execution completed ===" -Level "INFO"
}
#endregion
