[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [switch]$TestConnection
)

# Configuration - Modify these values
$vCenterServers = @("vcenter01.domain.com", "vcenter02.domain.com")
$SDDCApiUrl = "https://vmc.vmware.com/vmc/api"
$KeyDirectory = "./keys"

# Configuration
$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

# Initialize logging
$LogFile = "ESXi-KeyDeployment-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogMessage = "[$Timestamp] [$Level] $Message"
    Write-Host $LogMessage
    Add-Content -Path $LogFile -Value $LogMessage
}

#region SSH Key Generation
function New-RSAKeyPair {
    param(
        [string]$KeyPath,
        [int]$KeySize = 4096
    )
    
    Write-Log "Generating RSA $KeySize-bit SSH key pair..."
    
    # Ensure directory exists
    $KeyDir = Split-Path -Parent $KeyPath
    if (!(Test-Path $KeyDir)) {
        New-Item -ItemType Directory -Path $KeyDir -Force | Out-Null
    }
    
    # Generate key using ssh-keygen (cross-platform in PS7)
    $PrivateKeyPath = "$KeyPath"
    $PublicKeyPath = "$KeyPath.pub"
    
    # Check if ssh-keygen is available
    if (!(Get-Command ssh-keygen -ErrorAction SilentlyContinue)) {
        throw "ssh-keygen not found. Please install OpenSSH client."
    }
    
    # Generate key (no passphrase for automation)
    $sshKeyGenArgs = @(
        "-t", "rsa",
        "-b", $KeySize,
        "-f", $PrivateKeyPath,
        "-N", '""',
        "-C", "esxi-automation-$(Get-Date -Format 'yyyyMMdd')"
    )
    
    & ssh-keygen @sshKeyGenArgs 2>&1 | Out-Null
    
    if (!(Test-Path $PrivateKeyPath) -or !(Test-Path $PublicKeyPath)) {
        throw "Failed to generate SSH key pair"
    }
    
    Write-Log "SSH key pair generated successfully at $KeyDir" -Level "SUCCESS"
    
    return @{
        PrivateKey = $PrivateKeyPath
        PublicKey = $PublicKeyPath
        PublicKeyContent = Get-Content $PublicKeyPath -Raw
    }
}
#endregion

#region SDDC API Authentication
function Get-SDDCApiToken {
    param(
        [string]$ApiUrl,
        [PSCredential]$Credential
    )
    
    Write-Log "Authenticating with SDDC API..."
    
    try {
        # Example for VMware Cloud (VMC) - adjust for your SDDC platform
        $AuthEndpoint = "$ApiUrl/auth/api-tokens/authorize"
        
        $Headers = @{
            "Content-Type" = "application/json"
        }
        
        $Body = @{
            refresh_token = $Credential.GetNetworkCredential().Password
        } | ConvertTo-Json
        
        $Response = Invoke-RestMethod -Uri $AuthEndpoint -Method Post -Headers $Headers -Body $Body
        
        Write-Log "SDDC API token retrieved successfully" -Level "SUCCESS"
        return $Response.access_token
    }
    catch {
        Write-Log "Failed to authenticate with SDDC API: $_" -Level "ERROR"
        throw
    }
}
#endregion

#region ESXi Host Discovery
function Get-ESXiHostsFromSDDC {
    param(
        [string]$ApiUrl,
        [string]$Token
    )
    
    Write-Log "Retrieving ESXi hosts from SDDC API..."
    
    try {
        # Adjust endpoint based on your SDDC platform
        $HostsEndpoint = "$ApiUrl/inventory/hosts"
        
        $Headers = @{
            "Authorization" = "Bearer $Token"
            "Content-Type" = "application/json"
        }
        
        $Response = Invoke-RestMethod -Uri $HostsEndpoint -Method Get -Headers $Headers
        
        # Parse response (adjust based on your API response structure)
        $Hosts = $Response.hosts | ForEach-Object {
            [PSCustomObject]@{
                Hostname = $_.name
                IPAddress = $_.ip_address
                Username = $_.credentials.username
                Password = $_.credentials.password
            }
        }
        
        Write-Log "Retrieved $($Hosts.Count) ESXi hosts" -Level "SUCCESS"
        return $Hosts
    }
    catch {
        Write-Log "Failed to retrieve ESXi hosts: $_" -Level "ERROR"
        throw
    }
}
#endregion

#region SSH Key Deployment
function Deploy-SSHKeyToESXi {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ESXiHost,
        
        [Parameter(Mandatory=$true)]
        [PSCredential]$Credential,
        
        [Parameter(Mandatory=$true)]
        [string]$PublicKey
    )
    
    Write-Log "Deploying SSH key to $ESXiHost..."
    
    try {
        # Connect via SSH using Posh-SSH module (install if needed)
        if (!(Get-Module -ListAvailable -Name Posh-SSH)) {
            Write-Log "Installing Posh-SSH module..." -Level "WARN"
            Install-Module -Name Posh-SSH -Force -Scope CurrentUser
        }
        
        Import-Module Posh-SSH -ErrorAction Stop
        
        # Establish SSH session
        $Session = New-SSHSession -ComputerName $ESXiHost -Credential $Credential -AcceptKey
        
        if (!$Session) {
            throw "Failed to establish SSH session"
        }
        
        # Prepare authorized_keys directory
        $Commands = @(
            "mkdir -p /etc/ssh/keys-root",
            "chmod 700 /etc/ssh/keys-root",
            "touch /etc/ssh/keys-root/authorized_keys",
            "chmod 600 /etc/ssh/keys-root/authorized_keys"
        )
        
        foreach ($Cmd in $Commands) {
            Invoke-SSHCommand -SessionId $Session.SessionId -Command $Cmd | Out-Null
        }
        
        # Check if key already exists
        $CheckKey = Invoke-SSHCommand -SessionId $Session.SessionId -Command "grep -F `"$PublicKey`" /etc/ssh/keys-root/authorized_keys"
        
        if ($CheckKey.Output) {
            Write-Log "Public key already exists on $ESXiHost" -Level "WARN"
        }
        else {
            # Append public key
            $EscapedKey = $PublicKey.Replace('"', '\"')
            $AddKeyCmd = "echo `"$EscapedKey`" >> /etc/ssh/keys-root/authorized_keys"
            Invoke-SSHCommand -SessionId $Session.SessionId -Command $AddKeyCmd | Out-Null
            
            Write-Log "SSH key deployed to $ESXiHost successfully" -Level "SUCCESS"
        }
        
        # Persist configuration across reboots
        Invoke-SSHCommand -SessionId $Session.SessionId -Command "/sbin/auto-backup.sh" | Out-Null
        
        # Close session
        Remove-SSHSession -SessionId $Session.SessionId | Out-Null
        
        return $true
    }
    catch {
        Write-Log "Failed to deploy key to $ESXiHost : $_" -Level "ERROR"
        return $false
    }
}
#endregion

#region Main Execution
try {
    Write-Log "=== ESXi SSH Key Deployment Automation Started ===" -Level "INFO"
    
    # Step 1: Connect to vCenter servers
    Write-Log "Connecting to vCenter servers..."
    $vCenterCred = Get-Credential -Message "Enter vCenter credentials"
    
    foreach ($vCenter in $vCenterServers) {
        try {
            Connect-VIServer -Server $vCenter -Credential $vCenterCred -ErrorAction Stop | Out-Null
            Write-Log "Connected to vCenter: $vCenter" -Level "SUCCESS"
        }
        catch {
            Write-Log "Failed to connect to $vCenter : $_" -Level "ERROR"
        }
    }
    
    # Step 2: Authenticate with SDDC API
    $SDDCCred = Get-Credential -Message "Enter SDDC API token (use token as password)"
    $ApiToken = Get-SDDCApiToken -ApiUrl $SDDCApiUrl -Credential $SDDCCred
    
    # Step 3: Generate SSH key pair
    $KeyPath = Join-Path $KeyDirectory "esxi_automation_key"
    $KeyPair = New-RSAKeyPair -KeyPath $KeyPath -KeySize 4096
    
    Write-Log "Private Key: $($KeyPair.PrivateKey)"
    Write-Log "Public Key: $($KeyPair.PublicKey)"
    
    # Step 4: Retrieve ESXi hosts from SDDC API
    $ESXiHosts = Get-ESXiHostsFromSDDC -ApiUrl $SDDCApiUrl -Token $ApiToken
    
    if ($ESXiHosts.Count -eq 0) {
        Write-Log "No ESXi hosts found" -Level "WARN"
        exit 0
    }
    
    # Step 5: Deploy SSH key to each host
    $Results = @()
    foreach ($Host in $ESXiHosts) {
        $HostCred = New-Object System.Management.Automation.PSCredential(
            $Host.Username,
            (ConvertTo-SecureString $Host.Password -AsPlainText -Force)
        )
        
        $Success = Deploy-SSHKeyToESXi -ESXiHost $Host.IPAddress -Credential $HostCred -PublicKey $KeyPair.PublicKeyContent.Trim()
        
        $Results += [PSCustomObject]@{
            Hostname = $Host.Hostname
            IPAddress = $Host.IPAddress
            Status = if ($Success) { "SUCCESS" } else { "FAILED" }
            Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        }
    }
    
    # Step 6: Generate report
    Write-Log "`n=== Deployment Summary ===" -Level "INFO"
    $Results | Format-Table -AutoSize
    
    $ReportPath = "ESXi-KeyDeployment-Report-$(Get-Date -Format 'yyyyMMdd-HHmmss').csv"
    $Results | Export-Csv -Path $ReportPath -NoTypeInformation
    Write-Log "Report saved to: $ReportPath" -Level "SUCCESS"
    
    # Optional: Test key-based authentication
    if ($TestConnection) {
        Write-Log "`n=== Testing SSH Key Authentication ===" -Level "INFO"
        foreach ($Host in $ESXiHosts | Select-Object -First 1) {
            Write-Log "Testing connection to $($Host.IPAddress)..."
            # Implementation for testing key auth would go here
        }
    }
}
catch {
    Write-Log "Critical error: $_" -Level "ERROR"
    throw
}
finally {
    # Disconnect from all vCenter servers
    if ($global:DefaultVIServers) {
        Disconnect-VIServer -Server * -Confirm:$false -ErrorAction SilentlyContinue
        Write-Log "Disconnected from all vCenter servers" -Level "INFO"
    }
    
    Write-Log "=== Script execution completed ===" -Level "INFO"
}
#endregion
