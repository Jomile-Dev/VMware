# New Server Tracker - Aria Operations + Multi-vRA
# PowerShell 5.1 Compatible
# Tracks servers built in the last day from Aria Operations and correlates with vRA deployments

# Configuration Variables
$ariaOpsServer = "aria-ops.yourdomain.com"
$ariaOpsDomain = "yourdomain.com"  # Domain for Aria Operations authentication
$ariaOpsAuthSource = "localos"  # Common values: localos, Active Directory, vIDMAuthSource, etc.
$vraServers = @(
    "vra1.yourdomain.com",
    "vra2.yourdomain.com"
)

# SMTP Configuration
$smtpServer = "smtp.yourdomain.com"
$smtpPort = 587
$smtpFrom = "vra-reports@yourdomain.com"
$smtpTo = @("admin@yourdomain.com")
$smtpSubject = "New Server Deployment Report - $(Get-Date -Format 'yyyy-MM-dd')"

# Time range for new VMs (in days)
$daysBack = 1

# Output
$timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
$outputLog = "C:\Logs\NewServers_$timestamp.log"
$outputCSV = "C:\Logs\NewServers_$timestamp.csv"

# Helper Functions
function Write-DebugLog {
    param(
        [string]$Message,
        [string]$Level = "INFO"
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] [$Level] $Message"
    
    $color = "Cyan"
    switch ($Level) {
        "ERROR" { $color = "Red" }
        "WARN" { $color = "Yellow" }
        "SUCCESS" { $color = "Green" }
    }
    
    Write-Host $logMessage -ForegroundColor $color
    Add-Content -Path $outputLog -Value $logMessage
}

function Disable-SSLValidation {
    if (-not ([System.Management.Automation.PSTypeName]'TrustAllCertsPolicy').Type) {
        Add-Type @"
using System.Net;
using System.Security.Cryptography.X509Certificates;
public class TrustAllCertsPolicy : ICertificatePolicy {
    public bool CheckValidationResult(
        ServicePoint svcPoint, X509Certificate certificate,
        WebRequest request, int certificateProblem) {
        return true;
    }
}
"@
        [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
    }
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
}

function Send-NewServerReport {
    param(
        [Parameter(Mandatory=$true)]
        [Array]$ReportData,
        
        [Parameter(Mandatory=$true)]
        [string]$SmtpServer,
        
        [Parameter(Mandatory=$true)]
        [int]$SmtpPort,
        
        [Parameter(Mandatory=$true)]
        [string]$From,
        
        [Parameter(Mandatory=$true)]
        [Array]$To,
        
        [Parameter(Mandatory=$true)]
        [string]$Subject,
        
        [Parameter(Mandatory=$false)]
        [int]$DaysBack = 1,
        
        [Parameter(Mandatory=$false)]
        [string]$CsvPath
    )
    
    Write-DebugLog "Building email report..."
    
    # Build HTML table for email
    $htmlRows = ""
    foreach ($record in $ReportData) {
        # Color code rows based on source
        $rowClass = ""
        if ($record.Source -eq "vCenter Direct") {
            $rowClass = " style='background-color: #fff3cd;'"  # Light yellow for vCenter direct builds
        }
        
        $htmlRows += "<tr$rowClass>"
        $htmlRows += "<td>$($record.Name)</td>"
        $htmlRows += "<td>$($record.Status)</td>"
        $htmlRows += "<td>$($record.CreatedDate)</td>"
        $htmlRows += "<td>$($record.Source)</td>"
        $htmlRows += "<td>$($record.CreatedBy)</td>"
        $htmlRows += "<td>$($record.DeploymentName)</td>"
        $htmlRows += "<td>$($record.CatalogItem)</td>"
        $htmlRows += "<td>$($record.vRAServer)</td>"
        $htmlRows += "</tr>"
    }
    
    $htmlTable = @"
<table>
<thead>
<tr>
<th>Name</th>
<th>Status</th>
<th>Created Date</th>
<th>Source</th>
<th>Created By</th>
<th>Deployment Name</th>
<th>Catalog Item</th>
<th>vRA Server</th>
</tr>
</thead>
<tbody>
$htmlRows
</tbody>
</table>
"@
    
    $vraCount = ($ReportData | Where-Object { $_.Source -eq "vRA" }).Count
    $vcenterCount = ($ReportData | Where-Object { $_.Source -eq "vCenter Direct" }).Count
    
    $currentDate = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $htmlBody = @"
<html>
<head>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h2 { color: #333; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th { background-color: #4CAF50; color: white; padding: 12px; text-align: left; font-weight: bold; }
    td { border: 1px solid #ddd; padding: 10px; }
    tr:nth-child(even) { background-color: #f2f2f2; }
    tr:hover { background-color: #e8e8e8; }
    .summary { background-color: #f9f9f9; padding: 15px; border-left: 4px solid #4CAF50; margin-bottom: 20px; }
    .footer { margin-top: 20px; font-size: 12px; color: #666; }
    .legend { margin-top: 10px; font-size: 14px; }
    .legend-item { display: inline-block; margin-right: 20px; }
    .legend-color { display: inline-block; width: 20px; height: 20px; margin-right: 5px; vertical-align: middle; border: 1px solid #ddd; }
</style>
</head>
<body>
<h2>New Server Deployment Report</h2>
<div class="summary">
    <p><strong>Generated:</strong> $currentDate</p>
    <p><strong>Total New Servers:</strong> $($ReportData.Count)</p>
    <p><strong>Built via vRA:</strong> $vraCount</p>
    <p><strong>Built directly in vCenter:</strong> $vcenterCount</p>
    <p><strong>Time Range:</strong> Last $DaysBack day(s)</p>
</div>
<div class="legend">
    <div class="legend-item"><span class="legend-color" style="background-color: #fff3cd;"></span>Built directly in vCenter</div>
    <div class="legend-item"><span class="legend-color" style="background-color: #f2f2f2;"></span>Built via vRA</div>
</div>
$htmlTable
<div class="footer">
    <p>CSV report also saved to: $CsvPath</p>
</div>
</body>
</html>
"@
    
    Write-DebugLog "Sending email to: $($To -join ', ')"
    Send-MailMessage -To $To -From $From -Subject $Subject -Body $htmlBody -BodyAsHtml -SmtpServer $SmtpServer -Port $SmtpPort -UseSsl
    Write-DebugLog "Email sent successfully!" "SUCCESS"
}

# Main Script
Write-DebugLog "===== Script Started =====" "SUCCESS"
Write-DebugLog "PowerShell Version: $($PSVersionTable.PSVersion)"
Write-DebugLog "Output CSV: $outputCSV"
Write-DebugLog "Combined Log: $outputLog"

# Ensure log directory exists
$logDir = Split-Path $outputCSV -Parent
if (!(Test-Path $logDir)) {
    New-Item -ItemType Directory -Path $logDir -Force | Out-Null
    Write-DebugLog "Created log directory: $logDir"
}

Disable-SSLValidation
Write-DebugLog "SSL validation disabled"

# Get credentials once for all connections
Write-DebugLog "Requesting credentials..."
$credential = Get-Credential -Message "Enter credentials for Aria Operations and vRA"
if (-not $credential) {
    Write-DebugLog "Credentials not provided. Exiting." "ERROR"
    exit
}
$username = $credential.UserName
$password = $credential.GetNetworkCredential().Password
Write-DebugLog "Credentials obtained for user: $username"

# Connect to Aria Operations and Get New VMs
Write-DebugLog "`n===== Connecting to Aria Operations =====" "INFO"
$ariaToken = $null
$newVMsData = @()

try {
    Write-DebugLog "Authenticating to Aria Operations: $ariaOpsServer"
    
    # Build vROps username format: username@domain@AuthSource
    $ariaUsername = "$username@$ariaOpsDomain@$ariaOpsAuthSource"
    Write-DebugLog "vROps authentication username: $ariaUsername"
    
    $ariaAuthUri = "https://$ariaOpsServer/suite-api/api/auth/token/acquire"
    $ariaAuthBody = @{
        username = $ariaUsername
        password = $password
    } | ConvertTo-Json
    
    $ariaAuthHeaders = @{
        "Content-Type" = "application/json"
        "Accept" = "application/json"
    }
    
    $ariaAuthResponse = Invoke-RestMethod -Uri $ariaAuthUri -Method Post -Headers $ariaAuthHeaders -Body $ariaAuthBody -ErrorAction Stop
    $ariaToken = $ariaAuthResponse.token
    Write-DebugLog "Authenticated to Aria Operations successfully" "SUCCESS"
    
    $ariaHeaders = @{
        "Authorization" = "vRealizeOpsToken $ariaToken"
        "Content-Type" = "application/json"
        "Accept" = "application/json"
    }
    
    # Calculate time range for query (last X days in MILLISECONDS since epoch)
    # Aria Operations API typically uses milliseconds for timestamps
    $cutoffDate = (Get-Date).AddDays(-$daysBack)
    $cutoffEpochMs = [long]([datetime]$cutoffDate - [datetime]'1970-01-01').TotalMilliseconds
    
    Write-DebugLog "Searching for VMs created after: $cutoffDate"
    Write-DebugLog "Cutoff epoch time (milliseconds): $cutoffEpochMs"
    
    # Query Aria Operations for VMs created in the last X days
    # Using createdAfter parameter to filter on the server side
    Write-DebugLog "Querying Aria Operations for newly created VMs using createdAfter filter..."
    
    # Query with createdAfter to get ONLY VMs created in the time range - this is the key to speed
    $resourceQueryUri = "https://$ariaOpsServer/suite-api/api/resources?resourceKind=VirtualMachine&createdAfter=$cutoffEpochMs&pageSize=1000"
    Write-DebugLog "API Query: $resourceQueryUri"
    
    $page = 0
    $foundNewVMs = 0
    
    do {
        $pagedResourceUri = "$resourceQueryUri&page=$page"
        Write-DebugLog "  Fetching page $page from Aria Operations (VMs created after $cutoffDate)..."
        
        $resourceResponse = Invoke-RestMethod -Uri $pagedResourceUri -Method Get -Headers $ariaHeaders -ErrorAction Stop
        
        if ($resourceResponse.resourceList) {
            $vmCount = $resourceResponse.resourceList.Count
            Write-DebugLog "  Retrieved $vmCount new VMs from page $page - processing..."
            
            # Process VMs using PowerShell 5.1 compatible runspaces for parallel processing
            $RunspacePool = [runspacefactory]::CreateRunspacePool(1, 10)
            $RunspacePool.Open()
            $Jobs = @()
            
            foreach ($resource in $resourceResponse.resourceList) {
                $PowerShell = [powershell]::Create()
                $PowerShell.RunspacePool = $RunspacePool
                
                [void]$PowerShell.AddScript({
                    param($resource, $ariaOpsServer, $ariaHeaders)
                    
                    try {
                        $resourceId = $resource.identifier
                        
                        # Get VM name from resourceKey.name
                        $vmName = $null
                        if ($resource.resourceKey.name) {
                            $vmName = $resource.resourceKey.name
                        }
                        
                        # Get detailed properties for this resource to get the actual VM name
                        $statsUri = "https://$ariaOpsServer/suite-api/api/resources/$resourceId/properties"
                        $statsResponse = Invoke-RestMethod -Uri $statsUri -Method Get -Headers $ariaHeaders -ErrorAction Stop
                        
                        # Look for the actual VM name from config
                        $vSphereMachineProp = $statsResponse.property | Where-Object { 
                            $_.name -eq "config|name" -or $_.name -eq "summary|config|name"
                        } | Select-Object -First 1
                        
                        if ($vSphereMachineProp -and $vSphereMachineProp.value) {
                            $vmName = $vSphereMachineProp.value
                        }
                        
                        if (-not $vmName) {
                            return $null
                        }
                        
                        # Get creation time for display purposes
                        $creationTimeProp = $statsResponse.property | Where-Object { 
                            $_.name -eq "summary|createdTime" -or 
                            $_.name -eq "sys|createdTime" -or
                            $_.name -eq "config|createDate"
                        } | Select-Object -First 1
                        
                        $creationDate = Get-Date
                        
                        if ($creationTimeProp -and $creationTimeProp.value) {
                            try {
                                $creationTimeMs = [long]$creationTimeProp.value
                                $epochStart = [datetime]'1970-01-01'
                                $creationDate = $epochStart.AddMilliseconds($creationTimeMs)
                            }
                            catch {
                                # Use current date as fallback
                            }
                        }
                        
                        # Get the user who created the VM from vCenter events
                        $createdByUser = "N/A"
                        $createdByProp = $statsResponse.property | Where-Object { 
                            $_.name -eq "config|createBy" -or 
                            $_.name -eq "summary|config|annotation" -or
                            $_.name -eq "sys|createdBy"
                        } | Select-Object -First 1
                        
                        if ($createdByProp -and $createdByProp.value) {
                            $createdByUser = $createdByProp.value
                        }
                        
                        # Get health status
                        $healthState = $resource.resourceStatusStates | Where-Object { $_.resourceState -eq "HEALTH" } | Select-Object -First 1
                        $status = if ($healthState) { $healthState.status } else { "UNKNOWN" }
                        
                        $simpleStatus = "Unknown"
                        switch ($status) {
                            "GREEN" { $simpleStatus = "Online" }
                            "YELLOW" { $simpleStatus = "Online" }
                            "ORANGE" { $simpleStatus = "Online" }
                            "RED" { $simpleStatus = "Decomm/Offline" }
                            "GREY" { $simpleStatus = "Decomm/Offline" }
                            default { $simpleStatus = "Decomm/Offline" }
                        }
                        
                        # Return VM data object
                        return [PSCustomObject]@{
                            Name = $vmName
                            CreatedDate = $creationDate
                            Status = $simpleStatus
                            ResourceId = $resourceId
                            CreatedByUser = $createdByUser
                        }
                    }
                    catch {
                        return $null
                    }
                })
                
                [void]$PowerShell.AddArgument($resource)
                [void]$PowerShell.AddArgument($ariaOpsServer)
                [void]$PowerShell.AddArgument($ariaHeaders)
                
                $Jobs += [PSCustomObject]@{
                    PowerShell = $PowerShell
                    Handle = $PowerShell.BeginInvoke()
                }
            }
            
            # Wait for all jobs to complete and collect results
            Write-DebugLog "  Processing $($Jobs.Count) VMs in parallel (up to 10 at a time)..."
            foreach ($Job in $Jobs) {
                $result = $Job.PowerShell.EndInvoke($Job.Handle)
                if ($result) {
                    $newVMsData += $result
                    $foundNewVMs++
                    Write-DebugLog "    Stored VM: $($result.Name) | Status: $($result.Status) | Created: $($result.CreatedDate)"
                }
                $Job.PowerShell.Dispose()
            }
            
            $RunspacePool.Close()
            $RunspacePool.Dispose()
        }
        
        $page++
        $hasMore = $resourceResponse.pageInfo.totalCount -gt ($page * 1000)
        
    } while ($hasMore)
    
    Write-DebugLog "`nFound $foundNewVMs VMs created in the last $daysBack day(s) from Aria Operations" "SUCCESS"
}
catch {
    Write-DebugLog "Failed to query Aria Operations: $($_.Exception.Message)" "ERROR"
    Write-DebugLog "Error details: $($_.Exception)" "ERROR"
    Write-DebugLog "Cannot continue without Aria Operations data. Exiting." "ERROR"
    exit
}

if ($newVMsData.Count -eq 0) {
    Write-DebugLog "`nNo new VMs found in Aria Operations. Exiting." "WARN"
    exit
}

# Connect to vRA and Get Deployment Info
Write-DebugLog "`n===== Processing vRA Servers =====" "INFO"
$deploymentData = @{}

foreach ($vraServer in $vraServers) {
    Write-DebugLog "`n--- Connecting to vRA $vraServer ---" "INFO"
    
    try {
        # Authenticate to vRA
        Write-DebugLog "Authenticating to $vraServer..."
        $vraAuthUri = "https://$vraServer/csp/gateway/am/api/login"
        $vraAuthBody = @{
            username = $username
            password = $password
        } | ConvertTo-Json
        
        $vraAuthHeaders = @{
            "Content-Type" = "application/json"
            "Accept" = "application/json"
        }
        
        $vraAuthResponse = Invoke-RestMethod -Uri $vraAuthUri -Method Post -Headers $vraAuthHeaders -Body $vraAuthBody -ErrorAction Stop
        $vraToken = $vraAuthResponse.cspAuthToken
        Write-DebugLog "Authenticated to $vraServer successfully" "SUCCESS"
        
        $vraHeaders = @{
            "Authorization" = "Bearer $vraToken"
            "Content-Type" = "application/json"
        }
        
        # Fetch deployments
        Write-DebugLog "Fetching deployments from $vraServer..."
        $vraUri = "https://$vraServer/deployment/api/deployments"
        $page = 0
        $size = 1000
        $deploymentsFound = 0
        
        do {
            $pagedUri = "$vraUri`?page=$page&size=$size&expand=resources"
            Write-DebugLog "  Fetching page $($page + 1) (size: $size)..."
            Write-DebugLog "  DEBUG - Full URI being called: $pagedUri"
            
            $vraResponse = Invoke-RestMethod -Uri $pagedUri -Method Get -Headers $vraHeaders -ErrorAction Stop
            if ($vraResponse.content) {
                $deployments = $vraResponse.content
            } 
            else {
                $deployments = $vraResponse
            }
            
            Write-DebugLog "  Retrieved $($deployments.Count) deployments on page $($page + 1)"
            
            # Filter for deployments with vSphere machines
            $deploymentsWithVMs = @()
            foreach ($dep in $deployments) {
                if ($dep.resources) {
                    $hasVSphereMachine = $false
                    foreach ($res in $dep.resources) {
                        if ($res.type -eq "Cloud.vSphere.Machine") {
                            $hasVSphereMachine = $true
                            break
                        }
                    }
                    if ($hasVSphereMachine) {
                        $deploymentsWithVMs += $dep
                    }
                }
            }
            
            Write-DebugLog "  $($deploymentsWithVMs.Count) deployments have vSphere machines"
            
            foreach ($dep in $deploymentsWithVMs) {
                $vSphereMachines = @()
                foreach ($res in $dep.resources) {
                    if ($res.type -eq "Cloud.vSphere.Machine") {
                        $vSphereMachines += $res
                    }
                }
                
                foreach ($machine in $vSphereMachines) {
                    # Get hostname from various possible properties
                    $hostname = $null
                    
                    # Try common property names
                    if ($machine.properties) {
                        $props = $machine.properties
                        
                        # Priority order for finding hostname
                        if ($props.hostname) { 
                            $hostname = $props.hostname 
                            Write-DebugLog "    Found hostname in properties.hostname: $hostname"
                        } 
                        elseif ($props.resourceName) {
                            $hostname = $props.resourceName
                            Write-DebugLog "    Found hostname in properties.resourceName: $hostname"
                        }
                        elseif ($props.name) {
                            $hostname = $props.name
                            Write-DebugLog "    Found hostname in properties.name: $hostname"
                        }
                        elseif ($props.address) {
                            $hostname = $props.address
                            Write-DebugLog "    Found hostname in properties.address: $hostname"
                        }
                        elseif ($props.hostName) {
                            $hostname = $props.hostName
                            Write-DebugLog "    Found hostname in properties.hostName: $hostname"
                        }
                    }
                    
                    # Fallback to machine name
                    if (-not $hostname -and $machine.name) {
                        $hostname = $machine.name
                        Write-DebugLog "    Found hostname in machine.name: $hostname"
                    }
                    
                    if ($hostname) {
                        # Only store if not already found in a previous vRA
                        if (-not $deploymentData.ContainsKey($hostname)) {
                            $deploymentsFound++
                            
                            $description = "N/A"
                            if ($dep.description) {
                                $description = $dep.description
                            }
                            
                            $requestedBy = "N/A"
                            if ($dep.createdBy) {
                                $requestedBy = $dep.createdBy
                            }
                            
                            $requestor = $requestedBy
                            if ($dep.ownedBy) {
                                $requestor = $dep.ownedBy
                            }
                            
                            # Extract first part of FQDN
                            $vraServerShort = ($vraServer -split '\.')[0]
                            
                            # Get catalog item from customProperties.category
                            $catalogItem = "N/A"
                            if ($dep.customProperties -and $dep.customProperties.category) {
                                $catalogItem = $dep.customProperties.category
                                Write-DebugLog "    Found catalog item: $catalogItem"
                            }
                            
                            $deploymentData[$hostname] = @{
                                DeploymentName = $dep.name
                                Description = $description
                                RequestedBy = $requestedBy
                                Requestor = $requestor
                                vRAServer = $vraServerShort
                                DeploymentID = $dep.id
                                Status = $dep.status
                                CatalogItem = $catalogItem
                            }
                            
                            Write-DebugLog "    Stored deployment for $hostname from $vraServer"
                        }
                        else {
                            Write-DebugLog "    Skipping $hostname - already found in another vRA" "WARN"
                        }
                    }
                    else {
                        Write-DebugLog "    Could not determine hostname for machine in deployment $($dep.name)" "WARN"
                        Write-DebugLog "    Machine type: $($machine.type), Machine ID: $($machine.id)"
                        
                        # Log all available properties for debugging
                        if ($machine.properties) {
                            Write-DebugLog "    Available properties: $($machine.properties.Keys -join ', ')"
                        }
                    }
                }
            }
            
            $page++
            $hasMore = $false
            
            if ($vraResponse.totalPages) { 
                $hasMore = ($page -lt $vraResponse.totalPages)
            } 
            elseif ($vraResponse.totalElements) { 
                $hasMore = (($page * $size) -lt $vraResponse.totalElements)
            } 
            else { 
                $hasMore = ($deployments.Count -eq $size)
            }
            
        } while ($hasMore)
        
        Write-DebugLog "Completed scanning $vraServer - Found $deploymentsFound new deployments" "SUCCESS"
    }
    catch {
        Write-DebugLog "Error processing vRA server $vraServer : $($_.Exception.Message)" "ERROR"
        Write-DebugLog "Error details: $($_.Exception)" "ERROR"
    }
}

Write-DebugLog "`nTotal unique deployments found across all vRA servers: $($deploymentData.Count)" "SUCCESS"

# Log which VMs were not found in any vRA and mark them as Decomm
Write-DebugLog "`n--- VM to Deployment Matching ---" "INFO"
foreach ($vmData in $newVMsData) {
    if (-not $deploymentData.ContainsKey($vmData.Name)) {
        Write-DebugLog "VM '$($vmData.Name)' not found in any vRA deployment - Built directly in vCenter" "WARN"
        # For VMs not in vRA, check if we should mark as decomm based on status
        # If already marked as Decomm/Offline in Aria, keep it that way
    }
}

# Build Final Report
Write-DebugLog "`n===== Building Final Report =====" "INFO"
$reportData = @()

foreach ($vmData in $newVMsData) {
    $vmName = $vmData.Name
    
    # Try to find deployment info
    $depInfo = $null
    if ($deploymentData.ContainsKey($vmName)) {
        $depInfo = $deploymentData[$vmName]
    }
    
    if ($depInfo) {
        Write-DebugLog "Matched VM '$vmName' to deployment: $($depInfo.DeploymentName)"
        
        # VM found in vRA - use vRA deployment info
        $reportObject = New-Object PSObject -Property @{
            Name = $vmName
            Status = $vmData.Status
            CreatedDate = $vmData.CreatedDate
            DeploymentName = $depInfo.DeploymentName
            CatalogItem = $depInfo.CatalogItem
            RequestedBy = $depInfo.RequestedBy
            Requestor = $depInfo.Requestor
            vRAServer = $depInfo.vRAServer
            DeploymentStatus = $depInfo.Status
            CreatedBy = $depInfo.RequestedBy
            Source = "vRA"
        }
    }
    else {
        Write-DebugLog "No deployment found for VM: $vmName - Built directly in vCenter" "WARN"
        
        # VM NOT found in vRA - built directly in vCenter
        $reportObject = New-Object PSObject -Property @{
            Name = $vmName
            Status = $vmData.Status
            CreatedDate = $vmData.CreatedDate
            DeploymentName = "N/A - Built in vCenter"
            CatalogItem = "N/A"
            RequestedBy = "N/A"
            Requestor = "N/A"
            vRAServer = "N/A"
            DeploymentStatus = "N/A"
            CreatedBy = $vmData.CreatedByUser
            Source = "vCenter Direct"
        }
    }
    
    $reportData += $reportObject
}

Write-DebugLog "Report contains $($reportData.Count) records" "SUCCESS"

# Export to CSV
Write-DebugLog "`n===== Exporting Data =====" "INFO"
$reportData | Select-Object Name, Status, CreatedDate, Source, CreatedBy, DeploymentName, CatalogItem, RequestedBy, Requestor, vRAServer, DeploymentStatus | Export-Csv -Path $outputCSV -NoTypeInformation
Write-DebugLog "Exported to: $outputCSV" "SUCCESS"

# Send Email Report
Write-DebugLog "`n===== Sending Email Report =====" "INFO"
Send-NewServerReport `
    -ReportData $reportData `
    -SmtpServer $smtpServer `
    -SmtpPort $smtpPort `
    -From $smtpFrom `
    -To $smtpTo `
    -Subject $smtpSubject `
    -DaysBack $daysBack `
    -CsvPath $outputCSV

# Cleanup
Write-DebugLog "`n===== Cleanup =====" "INFO"
Write-DebugLog "`n===== Script Completed Successfully =====" "SUCCESS"
Write-DebugLog "Results saved to: $outputCSV"
Write-DebugLog "Log saved to: $outputLog"
Write-DebugLog "`n========================================`n"
Write-Host "`nPress any key to exit..." -ForegroundColor Yellow
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
