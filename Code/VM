# New Server Tracker - Aria Operations + Multi-vRA (Active & Deleted) + vCenter
# PowerShell 5.1 Compatible
# Tracks servers built in the last day from Aria Operations and correlates with vRA deployments (including deleted ones)

# Configuration Variables
$ariaOpsServer = "aria-ops.yourdomain.com"
$ariaOpsDomain = "yourdomain.com"
$ariaOpsAuthSource = "localos"
$vraServers = @(
    "vra1.yourdomain.com",
    "vra2.yourdomain.com"
)

# vCenter Configuration
$vCenters = @(
    "vcenter1.domain.com",
    "vcenter2.domain.com",
    "vcenter3.domain.com"
)

# SMTP Configuration
$smtpServer = "smtp.yourdomain.com"
$smtpPort = 587
$smtpFrom = "vra-reports@yourdomain.com"
$smtpTo = @("admin@yourdomain.com")
$smtpSubject = "New Server Deployment Report - $(Get-Date -Format 'yyyy-MM-dd')"

# Time range for new VMs (in days)
$daysBack = 1

# Deleted deployment search configuration
$deletedDaysBack = 90  # How far back to search for deleted deployments
$eventsPageSize = 200  # Events per page

# Output
$timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
$outputLog = "C:\Logs\NewServers_$timestamp.log"
$outputCSV = "C:\Logs\NewServers_$timestamp.csv"

# Helper Functions
function Write-DebugLog {
    param(
        [string]$Message,
        [string]$Level = "INFO"
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] [$Level] $Message"
    
    $color = "Cyan"
    switch ($Level) {
        "ERROR" { $color = "Red" }
        "WARN" { $color = "Yellow" }
        "SUCCESS" { $color = "Green" }
        "DEBUG" { $color = "Magenta" }
    }
    
    Write-Host $logMessage -ForegroundColor $color
    Add-Content -Path $outputLog -Value $logMessage
}

function Disable-SSLValidation {
    if (-not ([System.Management.Automation.PSTypeName]'TrustAllCertsPolicy').Type) {
        Add-Type @"
using System.Net;
using System.Security.Cryptography.X509Certificates;
public class TrustAllCertsPolicy : ICertificatePolicy {
    public bool CheckValidationResult(
        ServicePoint svcPoint, X509Certificate certificate,
        WebRequest request, int certificateProblem) {
        return true;
    }
}
"@
        [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
    }
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
}

function Get-DeletedDeploymentVMs {
    param(
        [string]$VraServer,
        [hashtable]$Headers,
        [int]$DaysBack
    )
    
    Write-DebugLog "  Searching for deleted deployments in last $DaysBack days..." "DEBUG"
    
    $deletedVMs = @{}
    $cutoffDate = (Get-Date).AddDays(-$DaysBack)
    
    # Try different URL variations for deleted deployments
    $urlVariations = @(
        "https://$VraServer/deployment/api/deployments?deleted=true&apiVersion=2020-08-25&page={0}&size=200",
        "https://$VraServer/deployment/api/deployments?deleted=%5Btrue%5D&apiVersion=2020-08-25&page={0}&size=200"
    )
    
    $workingUrl = $null
    $allDeletedDeployments = @()
    
    # Find working URL
    foreach ($urlTemplate in $urlVariations) {
        $testUrl = $urlTemplate -f 0
        try {
            $response = Invoke-RestMethod -Uri $testUrl -Method Get -Headers $Headers -ErrorAction Stop
            $deployments = if ($response.content) { $response.content } else { $response }
            
            if ($deployments -and $deployments.Count -gt 0) {
                $workingUrl = $urlTemplate
                $allDeletedDeployments += $deployments
                Write-DebugLog "    Found $($deployments.Count) deleted deployments" "DEBUG"
                break
            }
        }
        catch {
            continue
        }
    }
    
    if (-not $workingUrl) {
        Write-DebugLog "    No deleted deployments found or unable to access" "WARN"
        return $deletedVMs
    }
    
    # Fetch remaining pages
    $page = 1
    do {
        $uri = $workingUrl -f $page
        try {
            $response = Invoke-RestMethod -Uri $uri -Method Get -Headers $Headers -ErrorAction Stop
            $deployments = if ($response.content) { $response.content } else { $response }
            
            if ($deployments -and $deployments.Count -gt 0) {
                $allDeletedDeployments += $deployments
                $page++
            }
            else {
                break
            }
        }
        catch {
            break
        }
        
        if ($allDeletedDeployments.Count -ge 5000) {
            break
        }
        
    } while ($true)
    
    Write-DebugLog "    Total deleted deployments fetched: $($allDeletedDeployments.Count)" "DEBUG"
    
    # Filter by date
    $filteredDeployments = $allDeletedDeployments | Where-Object {
        try {
            $updateDate = [DateTime]$_.lastUpdatedAt
            $updateDate -ge $cutoffDate
        }
        catch {
            $true
        }
    }
    
    Write-DebugLog "    Deleted deployments in date range: $($filteredDeployments.Count)" "DEBUG"
    
    # Process each deleted deployment
    foreach ($deployment in $filteredDeployments) {
        Write-DebugLog "      Processing deleted deployment: $($deployment.name)" "DEBUG"
        
        # Get requests for this deployment
        try {
            $requestsUri = "https://$VraServer/deployment/api/deployments/$($deployment.id)/requests?apiVersion=2020-08-25&deleted=true"
            $requestsResponse = Invoke-RestMethod -Uri $requestsUri -Method Get -Headers $Headers -ErrorAction Stop
            $requests = if ($requestsResponse.content) { $requestsResponse.content } else { $requestsResponse }
            
            foreach ($request in $requests) {
                # Get events for this request
                $eventPage = 0
                
                do {
                    $eventsUri = "https://$VraServer/deployment/api/deployments/$($deployment.id)/requests/$($request.id)/events?page=$eventPage&size=$eventsPageSize&deleted=true&apiVersion=2020-08-25"
                    
                    try {
                        $eventsResponse = Invoke-RestMethod -Uri $eventsUri -Method Get -Headers $Headers -ErrorAction Stop
                        $events = if ($eventsResponse.content) { $eventsResponse.content } else { $eventsResponse }
                        
                        if (-not $events -or $events.Count -eq 0) {
                            break
                        }
                        
                        # Filter for Cloud.vSphere.Machine events
                        $vmEvents = $events | Where-Object { $_.resourceType -eq "Cloud.vSphere.Machine" }
                        
                        foreach ($event in $vmEvents) {
                            # Extract VM name from Details field
                            $vmName = $null
                            
                            # Check resourceName first
                            if ($event.resourceName) {
                                $vmName = $event.resourceName
                            }
                            
                            # Try to parse details for "Cloud Resource Name:"
                            if ($event.details) {
                                $detailsText = $null
                                
                                if ($event.details -is [string]) {
                                    $detailsText = $event.details
                                }
                                else {
                                    try {
                                        $detailsText = ($event.details | ConvertTo-Json -Compress -Depth 5)
                                    }
                                    catch {}
                                }
                                
                                if ($detailsText) {
                                    # Look for "Cloud Resource Name: XYZ" pattern
                                    if ($detailsText -match "Cloud Resource Name:\s*([^\s,\]\}]+)") {
                                        $vmName = $Matches[1]
                                        Write-DebugLog "        Extracted VM name from details: $vmName" "DEBUG"
                                    }
                                }
                            }
                            
                            if ($vmName -and -not $deletedVMs.ContainsKey($vmName)) {
                                # Get catalog item
                                $catalogItem = "N/A"
                                if ($deployment.inputs -and $deployment.inputs._catalogItemName) {
                                    $catalogItem = $deployment.inputs._catalogItemName
                                }
                                
                                $deletedVMs[$vmName] = @{
                                    DeploymentName = $deployment.name
                                    RequestedBy = if ($request.requestedBy) { $request.requestedBy } else { $deployment.lastUpdatedBy }
                                    Requestor = if ($deployment.ownedBy) { $deployment.ownedBy } else { $deployment.createdBy }
                                    CatalogItem = $catalogItem
                                    Status = "Decomm/Offline"
                                    DeletedAt = $deployment.lastUpdatedAt
                                }
                                
                                Write-DebugLog "        Found deleted VM: $vmName" "SUCCESS"
                            }
                        }
                        
                        $eventPage++
                        
                        if ($events.Count -lt $eventsPageSize) {
                            break
                        }
                    }
                    catch {
                        Write-DebugLog "        Error fetching events: $($_.Exception.Message)" "WARN"
                        break
                    }
                    
                } while ($true)
            }
        }
        catch {
            Write-DebugLog "      Error processing deployment: $($_.Exception.Message)" "WARN"
        }
    }
    
    Write-DebugLog "    Found $($deletedVMs.Count) VMs from deleted deployments" "SUCCESS"
    return $deletedVMs
}

function Send-NewServerReport {
    param(
        [Parameter(Mandatory=$true)]
        [Array]$ReportData,
        
        [Parameter(Mandatory=$true)]
        [string]$SmtpServer,
        
        [Parameter(Mandatory=$true)]
        [int]$SmtpPort,
        
        [Parameter(Mandatory=$true)]
        [string]$From,
        
        [Parameter(Mandatory=$true)]
        [Array]$To,
        
        [Parameter(Mandatory=$true)]
        [string]$Subject,
        
        [Parameter(Mandatory=$false)]
        [int]$DaysBack = 1,
        
        [Parameter(Mandatory=$false)]
        [string]$CsvPath
    )
    
    Write-DebugLog "Building email report..."
    
    # Build HTML table for email
    $htmlRows = ""
    foreach ($record in $ReportData) {
        # Color code rows based on source
        $rowClass = ""
        if ($record.Source -notlike "*vRA*") {
            $rowClass = " style='background-color: #fff3cd;'"
        }
        elseif ($record.Status -eq "Decomm/Offline") {
            $rowClass = " style='background-color: #f8d7da;'"
        }
        
        $htmlRows += "<tr$rowClass>"
        $htmlRows += "<td>$($record.Name)</td>"
        $htmlRows += "<td>$($record.Status)</td>"
        $htmlRows += "<td>$($record.Source)</td>"
        $htmlRows += "<td>$($record.RequestedBy)</td>"
        $htmlRows += "<td>$($record.Requestor)</td>"
        $htmlRows += "<td>$($record.DeploymentName)</td>"
        $htmlRows += "<td>$($record.CatalogItem)</td>"
        $htmlRows += "</tr>"
    }
    
    $htmlTable = @"
<table>
<thead>
<tr>
<th>Name</th>
<th>Status</th>
<th>Source</th>
<th>Requested By</th>
<th>Requestor</th>
<th>Deployment Name</th>
<th>Catalog Item</th>
</tr>
</thead>
<tbody>
$htmlRows
</tbody>
</table>
"@
    
    $htmlBody = @"
<html>
<head>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th { background-color: #4CAF50; color: white; padding: 12px; text-align: left; font-weight: bold; }
    td { border: 1px solid #ddd; padding: 10px; }
    tr:nth-child(even) { background-color: #f2f2f2; }
    tr:hover { background-color: #e8e8e8; }
    .summary { background-color: #f9f9f9; padding: 10px 15px; border-left: 4px solid #4CAF50; margin-bottom: 20px; }
</style>
</head>
<body>
<div class="summary">
    <p><strong>Total New Servers:</strong> $($ReportData.Count)</p>
</div>
$htmlTable
</body>
</html>
"@
    
    Write-DebugLog "Sending email to: $($To -join ', ')"
    Send-MailMessage -To $To -From $From -Subject $Subject -Body $htmlBody -BodyAsHtml -SmtpServer $SmtpServer -Port $SmtpPort -UseSsl
    Write-DebugLog "Email sent successfully!" "SUCCESS"
}

# Main Script
Write-DebugLog "===== Script Started =====" "SUCCESS"
Write-DebugLog "PowerShell Version: $($PSVersionTable.PSVersion)"
Write-DebugLog "Output CSV: $outputCSV"
Write-DebugLog "Combined Log: $outputLog"

# Load VMware PowerCLI
try {
    Import-Module VMware.VimAutomation.Core -ErrorAction Stop
    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session | Out-Null
    Write-DebugLog "VMware PowerCLI module loaded" "SUCCESS"
}
catch {
    Write-DebugLog "Failed to load VMware PowerCLI: $($_.Exception.Message)" "ERROR"
    Write-DebugLog "Install it with: Install-Module -Name VMware.PowerCLI -Scope CurrentUser" "ERROR"
    exit
}

# Ensure log directory exists
$logDir = Split-Path $outputCSV -Parent
if (!(Test-Path $logDir)) {
    New-Item -ItemType Directory -Path $logDir -Force | Out-Null
}

Disable-SSLValidation

# Get credentials
Write-DebugLog "Requesting credentials..."
$credential = Get-Credential -Message "Enter credentials for Aria Operations, vRA, and vCenter"
if (-not $credential) {
    Write-DebugLog "Credentials not provided. Exiting." "ERROR"
    exit
}
$username = $credential.UserName
$password = $credential.GetNetworkCredential().Password

# Connect to Aria Operations and Get New VMs
Write-DebugLog "`n===== Connecting to Aria Operations =====" "INFO"
$newVMsData = @()

try {
    Write-DebugLog "Authenticating to Aria Operations: $ariaOpsServer"
    
    $ariaUsername = "$username@$ariaOpsDomain@$ariaOpsAuthSource"
    $ariaAuthUri = "https://$ariaOpsServer/suite-api/api/auth/token/acquire"
    $ariaAuthBody = @{
        username = $ariaUsername
        password = $password
    } | ConvertTo-Json
    
    $ariaAuthResponse = Invoke-RestMethod -Uri $ariaAuthUri -Method Post -Headers @{"Content-Type"="application/json"} -Body $ariaAuthBody -ErrorAction Stop
    $ariaToken = $ariaAuthResponse.token
    Write-DebugLog "Authenticated to Aria Operations successfully" "SUCCESS"
    
    $ariaHeaders = @{
        "Authorization" = "vRealizeOpsToken $ariaToken"
        "Content-Type" = "application/json"
        "Accept" = "application/json"
        "X-Ops-API-use-unsupported" = "true"
    }
    
    Write-DebugLog "Token received (first 20 chars): $($ariaToken.Substring(0, [Math]::Min(20, $ariaToken.Length)))..." "DEBUG"
    
    # Calculate cutoff date
    $yesterday = [DateTimeOffset]::Now.AddDays(-$daysBack).ToUnixTimeMilliseconds()
    Write-DebugLog "Searching for VMs created after: $((Get-Date).AddDays(-$daysBack))"
    Write-DebugLog "Unix timestamp (ms): $yesterday" "DEBUG"
    
    # Test API connectivity first with a simple call
    Write-DebugLog "Testing API connectivity..." "DEBUG"
    try {
        $testUrl = "https://$ariaOpsServer/suite-api/api/resources?pageSize=1&resourceKind=VirtualMachine"
        Write-DebugLog "Test URL: $testUrl" "DEBUG"
        $testResponse = Invoke-WebRequest -Uri $testUrl -Headers $ariaHeaders -Method Get -ErrorAction Stop
        Write-DebugLog "Test call successful - Status: $($testResponse.StatusCode)" "SUCCESS"
    }
    catch {
        Write-DebugLog "Test call failed!" "ERROR"
        Write-DebugLog "Status Code: $($_.Exception.Response.StatusCode.value__)" "ERROR"
        Write-DebugLog "Status Description: $($_.Exception.Response.StatusDescription)" "ERROR"
        
        # Try to read error response
        try {
            $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
            $responseBody = $reader.ReadToEnd()
            Write-DebugLog "Error Response Body: $responseBody" "ERROR"
        }
        catch {}
        
        # Try alternative authorization header formats
        Write-DebugLog "Trying alternative authorization formats..." "WARN"
        
        # Alternative 1: Just the token without prefix
        $altHeaders1 = @{
            "Authorization" = $ariaToken
            "Content-Type" = "application/json"
            "Accept" = "application/json"
        }
        
        try {
            Write-DebugLog "Trying: Authorization = [token]" "DEBUG"
            $testResponse = Invoke-RestMethod -Uri $testUrl -Headers $altHeaders1 -Method Get -ErrorAction Stop
            Write-DebugLog "SUCCESS with plain token format!" "SUCCESS"
            $ariaHeaders = $altHeaders1
        }
        catch {
            Write-DebugLog "Plain token format failed" "WARN"
        }
        
        # Alternative 2: Bearer format
        $altHeaders2 = @{
            "Authorization" = "Bearer $ariaToken"
            "Content-Type" = "application/json"
            "Accept" = "application/json"
        }
        
        try {
            Write-DebugLog "Trying: Authorization = Bearer [token]" "DEBUG"
            $testResponse = Invoke-RestMethod -Uri $testUrl -Headers $altHeaders2 -Method Get -ErrorAction Stop
            Write-DebugLog "SUCCESS with Bearer token format!" "SUCCESS"
            $ariaHeaders = $altHeaders2
        }
        catch {
            Write-DebugLog "Bearer token format failed" "WARN"
        }
        
        # Alternative 3: CSPToken format
        $altHeaders3 = @{
            "Authorization" = "CSPToken $ariaToken"
            "Content-Type" = "application/json"
            "Accept" = "application/json"
        }
        
        try {
            Write-DebugLog "Trying: Authorization = CSPToken [token]" "DEBUG"
            $testResponse = Invoke-RestMethod -Uri $testUrl -Headers $altHeaders3 -Method Get -ErrorAction Stop
            Write-DebugLog "SUCCESS with CSPToken format!" "SUCCESS"
            $ariaHeaders = $altHeaders3
        }
        catch {
            Write-DebugLog "CSPToken format failed" "WARN"
        }
        
        # If none worked, throw error
        if ($testResponse -eq $null) {
            Write-DebugLog "All authorization formats failed. Cannot continue." "ERROR"
            Write-DebugLog "Possible issues:" "ERROR"
            Write-DebugLog "  1. User lacks 'Read Only' or higher permissions in Aria Ops" "ERROR"
            Write-DebugLog "  2. API version mismatch (check Aria Ops version)" "ERROR"
            Write-DebugLog "  3. Authentication source mismatch" "ERROR"
            throw "Cannot authenticate to Aria Operations API"
        }
    }
    
    # Query Aria Operations for new VMs with EXTREME debugging
    Write-DebugLog "`n===== QUERYING ARIA OPERATIONS - MAXIMUM DEBUG MODE =====" "INFO"
    Write-DebugLog "Current timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')" "DEBUG"
    
    # Verify all variables exist before starting
    Write-DebugLog "`n[PRE-CHECK] Verifying all required variables exist..." "INFO"
    Write-DebugLog "  ariaOpsServer exists: $($null -ne $ariaOpsServer) | Value: $ariaOpsServer" "DEBUG"
    Write-DebugLog "  ariaToken exists: $($null -ne $ariaToken) | Length: $($ariaToken.Length)" "DEBUG"
    Write-DebugLog "  ariaToken first 30 chars: $($ariaToken.Substring(0, [Math]::Min(30, $ariaToken.Length)))" "DEBUG"
    Write-DebugLog "  ariaHeaders exists: $($null -ne $ariaHeaders)" "DEBUG"
    
    if ($null -ne $ariaHeaders) {
        Write-DebugLog "  ariaHeaders type: $($ariaHeaders.GetType().Name)" "DEBUG"
        Write-DebugLog "  ariaHeaders keys: $($ariaHeaders.Keys -join ', ')" "DEBUG"
        foreach ($key in $ariaHeaders.Keys) {
            $value = $ariaHeaders[$key]
            if ($key -eq "Authorization") {
                Write-DebugLog "    $key = $($value.Substring(0, [Math]::Min(50, $value.Length)))..." "DEBUG"
            }
            else {
                Write-DebugLog "    $key = $value" "DEBUG"
            }
        }
    }
    else {
        Write-DebugLog "  ERROR: ariaHeaders is NULL!" "ERROR"
        throw "ariaHeaders variable is null"
    }
    
    # Build URL
    $ariaInternalURL = "https://$ariaOpsServer/suite-api/api/resources?resourceKind=VirtualMachine"
    Write-DebugLog "`n[URL] Target URL built: $ariaInternalURL" "INFO"
    Write-DebugLog "  URL Length: $($ariaInternalURL.Length)" "DEBUG"
    
    # Initialize ALL response variables with explicit null
    Write-DebugLog "`n[INIT] Initializing response variables..." "DEBUG"
    $webResponse = $null
    $response = $null
    $allResources = $null
    Write-DebugLog "  webResponse initialized to null: $($null -eq $webResponse)" "DEBUG"
    Write-DebugLog "  response initialized to null: $($null -eq $response)" "DEBUG"
    Write-DebugLog "  allResources initialized to null: $($null -eq $allResources)" "DEBUG"
    
    # ========== STEP 1: RAW HTTP REQUEST ==========
    Write-DebugLog "`n========== STEP 1: RAW HTTP REQUEST ==========" "INFO"
    Write-DebugLog "Attempting Invoke-WebRequest..." "INFO"
    Write-DebugLog "  Method: GET" "DEBUG"
    Write-DebugLog "  URI: $ariaInternalURL" "DEBUG"
    Write-DebugLog "  UseBasicParsing: True" "DEBUG"
    
    try {
        Write-DebugLog "  [1.1] Calling Invoke-WebRequest..." "DEBUG"
        
        $webResponse = Invoke-WebRequest -Uri $ariaInternalURL -Headers $ariaHeaders -Method Get -UseBasicParsing -ErrorAction Stop
        
        Write-DebugLog "  [1.2] Invoke-WebRequest completed without exception" "SUCCESS"
        Write-DebugLog "  [1.3] Checking if webResponse is null..." "DEBUG"
        
        if ($null -eq $webResponse) {
            Write-DebugLog "  [1.3] CRITICAL: webResponse is NULL after Invoke-WebRequest!" "ERROR"
            throw "Invoke-WebRequest returned null"
        }
        
        Write-DebugLog "  [1.3] webResponse is NOT null" "SUCCESS"
        Write-DebugLog "  [1.4] webResponse type: $($webResponse.GetType().FullName)" "DEBUG"
        
        Write-DebugLog "  [1.5] Checking webResponse.StatusCode..." "DEBUG"
        if ($null -ne $webResponse.StatusCode) {
            Write-DebugLog "  ✓ HTTP Status Code: $($webResponse.StatusCode)" "SUCCESS"
        }
        else {
            Write-DebugLog "  ✗ StatusCode is null" "WARN"
        }
        
        Write-DebugLog "  [1.6] Checking webResponse.Headers..." "DEBUG"
        if ($null -ne $webResponse.Headers) {
            Write-DebugLog "  ✓ Headers exist" "DEBUG"
            if ($webResponse.Headers['Content-Type']) {
                Write-DebugLog "    Content-Type: $($webResponse.Headers['Content-Type'])" "DEBUG"
            }
            if ($webResponse.Headers['Content-Length']) {
                Write-DebugLog "    Content-Length: $($webResponse.Headers['Content-Length'])" "DEBUG"
            }
        }
        else {
            Write-DebugLog "  ✗ Headers is null" "WARN"
        }
        
        Write-DebugLog "  [1.7] Checking webResponse.Content..." "DEBUG"
        if ($null -eq $webResponse.Content) {
            Write-DebugLog "  ✗ CRITICAL: Content is NULL!" "ERROR"
            throw "WebResponse Content is null"
        }
        
        Write-DebugLog "  ✓ Content exists" "SUCCESS"
        Write-DebugLog "  Content type: $($webResponse.Content.GetType().Name)" "DEBUG"
        Write-DebugLog "  Content length: $($webResponse.Content.Length) bytes" "DEBUG"
        
        if ($webResponse.Content.Length -eq 0) {
            Write-DebugLog "  ✗ WARNING: Content length is ZERO!" "WARN"
            Write-DebugLog "  This means the API returned an empty response" "WARN"
            Write-DebugLog "  Possible causes:" "WARN"
            Write-DebugLog "    - No VMs exist in Aria Operations" "WARN"
            Write-DebugLog "    - User lacks permission to view VMs" "WARN"
            Write-DebugLog "    - resourceKind=VirtualMachine doesn't match your environment" "WARN"
        }
        else {
            Write-DebugLog "  ✓ Content has data" "SUCCESS"
            
            # Show content preview
            $previewLength = [Math]::Min(2000, $webResponse.Content.Length)
            $preview = $webResponse.Content.Substring(0, $previewLength)
            Write-DebugLog "  [1.8] Content preview (first $previewLength chars):" "DEBUG"
            Write-DebugLog "================================================================" "DEBUG"
            Write-DebugLog $preview "DEBUG"
            Write-DebugLog "================================================================" "DEBUG"
            
            if ($webResponse.Content.Length -gt 2000) {
                Write-DebugLog "  (Content continues for $($webResponse.Content.Length - 2000) more bytes...)" "DEBUG"
            }
        }
        
        Write-DebugLog "  [1.9] Step 1 completed successfully" "SUCCESS"
        
    }
    catch {
        Write-DebugLog "  [1.ERROR] Invoke-WebRequest FAILED!" "ERROR"
        Write-DebugLog "  Exception Type: $($_.Exception.GetType().FullName)" "ERROR"
        Write-DebugLog "  Exception Message: $($_.Exception.Message)" "ERROR"
        
        if ($null -ne $_.Exception.InnerException) {
            Write-DebugLog "  Inner Exception: $($_.Exception.InnerException.Message)" "ERROR"
        }
        
        if ($null -ne $_.Exception.Response) {
            Write-DebugLog "  Response object exists, checking status..." "ERROR"
            
            try {
                $statusCode = [int]$_.Exception.Response.StatusCode
                $statusDesc = $_.Exception.Response.StatusDescription
                Write-DebugLog "  HTTP Status: $statusCode $statusDesc" "ERROR"
                
                switch ($statusCode) {
                    401 { 
                        Write-DebugLog "  >>> 401 UNAUTHORIZED <<<" "ERROR"
                        Write-DebugLog "  Token is invalid, expired, or authentication failed" "ERROR"
                        Write-DebugLog "  Check: Token format, expiration, user credentials" "ERROR"
                    }
                    403 { 
                        Write-DebugLog "  >>> 403 FORBIDDEN <<<" "ERROR"
                        Write-DebugLog "  User authenticated but lacks permissions" "ERROR"
                        Write-DebugLog "  Check: User needs 'Read Only' or higher role in Aria Ops" "ERROR"
                    }
                    404 { 
                        Write-DebugLog "  >>> 404 NOT FOUND <<<" "ERROR"
                        Write-DebugLog "  API endpoint doesn't exist" "ERROR"
                        Write-DebugLog "  Check: Aria Ops version, API path correctness" "ERROR"
                    }
                    500 { 
                        Write-DebugLog "  >>> 500 INTERNAL SERVER ERROR <<<" "ERROR"
                        Write-DebugLog "  Aria Operations had an internal error" "ERROR"
                        Write-DebugLog "  Check: Aria Ops logs, system health" "ERROR"
                    }
                    default { 
                        Write-DebugLog "  >>> HTTP ERROR $statusCode <<<" "ERROR"
                    }
                }
                
                # Try to read error response body
                Write-DebugLog "  Attempting to read error response body..." "ERROR"
                try {
                    $errorStream = $_.Exception.Response.GetResponseStream()
                    $reader = New-Object System.IO.StreamReader($errorStream)
                    $errorBody = $reader.ReadToEnd()
                    $reader.Close()
                    
                    if ($errorBody.Length -gt 0) {
                        Write-DebugLog "  Error Response Body:" "ERROR"
                        Write-DebugLog "================================================================" "ERROR"
                        Write-DebugLog $errorBody "ERROR"
                        Write-DebugLog "================================================================" "ERROR"
                    }
                    else {
                        Write-DebugLog "  Error response body is empty" "ERROR"
                    }
                }
                catch {
                    Write-DebugLog "  Could not read error response: $($_.Exception.Message)" "ERROR"
                }
            }
            catch {
                Write-DebugLog "  Could not extract status code: $($_.Exception.Message)" "ERROR"
            }
        }
        else {
            Write-DebugLog "  No Response object in exception (network error?)" "ERROR"
        }
        
        Write-DebugLog "  Stack Trace:" "ERROR"
        Write-DebugLog $_.ScriptStackTrace "ERROR"
        
        throw "HTTP request failed at Step 1: $($_.Exception.Message)"
    }
    
    # ========== STEP 2: PARSE JSON ==========
    Write-DebugLog "`n========== STEP 2: PARSE JSON ==========" "INFO"
    Write-DebugLog "Attempting to parse JSON with Invoke-RestMethod..." "INFO"
    
    try {
        Write-DebugLog "  [2.1] Calling Invoke-RestMethod..." "DEBUG"
        Write-DebugLog "    URI: $ariaInternalURL" "DEBUG"
        Write-DebugLog "    Method: GET" "DEBUG"
        
        $response = Invoke-RestMethod -Uri $ariaInternalURL -Headers $ariaHeaders -Method Get -ErrorAction Stop
        
        Write-DebugLog "  [2.2] Invoke-RestMethod completed" "SUCCESS"
        Write-DebugLog "  [2.3] Checking if response is null..." "DEBUG"
        
        if ($null -eq $response) {
            Write-DebugLog "  [2.3] CRITICAL ERROR: response is NULL!" "ERROR"
            Write-DebugLog "  This is very unusual - HTTP succeeded but JSON parsing returned null" "ERROR"
            Write-DebugLog "  The server may have returned empty JSON or invalid format" "ERROR"
            throw "Invoke-RestMethod returned null response"
        }
        
        Write-DebugLog "  [2.3] ✓ response is NOT null" "SUCCESS"
        Write-DebugLog "  [2.4] response type: $($response.GetType().FullName)" "DEBUG"
        Write-DebugLog "  [2.5] response base type: $($response.GetType().BaseType.FullName)" "DEBUG"
        
        Write-DebugLog "  [2.6] Checking if response is an Array..." "DEBUG"
        if ($response -is [Array]) {
            Write-DebugLog "  [2.6] ✓ YES - Response IS an Array" "SUCCESS"
            Write-DebugLog "    Array length: $($response.Count)" "DEBUG"
            Write-DebugLog "    Array element type: $($response[0].GetType().Name)" "DEBUG"
        }
        else {
            Write-DebugLog "  [2.6] NO - Response is NOT an Array" "DEBUG"
        }
        
        Write-DebugLog "  [2.7] Checking response.PSObject..." "DEBUG"
        if ($null -eq $response.PSObject) {
            Write-DebugLog "  [2.7] response.PSObject is NULL" "WARN"
        }
        else {
            Write-DebugLog "  [2.7] ✓ response.PSObject exists" "SUCCESS"
            Write-DebugLog "  [2.8] Checking response.PSObject.Properties..." "DEBUG"
            
            if ($null -eq $response.PSObject.Properties) {
                Write-DebugLog "  [2.8] response.PSObject.Properties is NULL" "WARN"
            }
            else {
                Write-DebugLog "  [2.8] ✓ response.PSObject.Properties exists" "SUCCESS"
                
                # Get property names safely
                $propertyNames = @()
                Write-DebugLog "  [2.9] Enumerating properties..." "DEBUG"
                
                try {
                    foreach ($prop in $response.PSObject.Properties) {
                        if ($null -ne $prop -and $null -ne $prop.Name) {
                            $propertyNames += $prop.Name
                            Write-DebugLog "    Found property: $($prop.Name) | Type: $($prop.TypeNameOfValue)" "DEBUG"
                        }
                    }
                }
                catch {
                    Write-DebugLog "  Error enumerating properties: $($_.Exception.Message)" "ERROR"
                }
                
                Write-DebugLog "  [2.10] Total properties found: $($propertyNames.Count)" "DEBUG"
                Write-DebugLog "  Property names: $($propertyNames -join ', ')" "SUCCESS"
            }
        }
        
        Write-DebugLog "  [2.11] Step 2 completed successfully" "SUCCESS"
        
    }
    catch {
        Write-DebugLog "  [2.ERROR] JSON Parsing FAILED!" "ERROR"
        Write-DebugLog "  Exception: $($_.Exception.Message)" "ERROR"
        Write-DebugLog "  Exception Type: $($_.Exception.GetType().FullName)" "ERROR"
        
        if ($null -ne $_.Exception.InnerException) {
            Write-DebugLog "  Inner Exception: $($_.Exception.InnerException.Message)" "ERROR"
        }
        
        Write-DebugLog "  Stack Trace:" "ERROR"
        Write-DebugLog $_.ScriptStackTrace "ERROR"
        
        throw "JSON parsing failed at Step 2: $($_.Exception.Message)"
    }
    
    # ========== STEP 3: EXTRACT RESOURCE DATA ==========
    Write-DebugLog "`n========== STEP 3: EXTRACT RESOURCE DATA ==========" "INFO"
    
    Write-DebugLog "  [3.1] Final null check on response..." "DEBUG"
    if ($null -eq $response) {
        Write-DebugLog "  [3.1] FATAL: response became null!" "ERROR"
        throw "Response is null at Step 3"
    }
    Write-DebugLog "  [3.1] ✓ response is still not null" "SUCCESS"
    
    Write-DebugLog "  [3.2] Determining response structure..." "INFO"
    $allResources = @()
    $dataFound = $false
    
    # Check if it's an array
    Write-DebugLog "  [3.3] Testing if response is Array..." "DEBUG"
    if ($response -is [Array]) {
        Write-DebugLog "  [3.3] ✓ Response IS an Array" "SUCCESS"
        $allResources = $response
        $dataFound = $true
        Write-DebugLog "    Array count: $($allResources.Count)" "DEBUG"
    }
    else {
        Write-DebugLog "  [3.3] Response is NOT an Array, checking properties..." "DEBUG"
        
        # Try to access PSObject safely
        Write-DebugLog "  [3.4] Safely accessing PSObject.Properties..." "DEBUG"
        $propertyNames = @()
        
        try {
            if ($null -ne $response.PSObject -and $null -ne $response.PSObject.Properties) {
                foreach ($prop in $response.PSObject.Properties) {
                    if ($null -ne $prop.Name) {
                        $propertyNames += $prop.Name
                    }
                }
                Write-DebugLog "  [3.4] ✓ Found $($propertyNames.Count) properties" "SUCCESS"
            }
            else {
                Write-DebugLog "  [3.4] PSObject or Properties is null" "WARN"
            }
        }
        catch {
            Write-DebugLog "  [3.4] ERROR accessing properties: $($_.Exception.Message)" "ERROR"
        }
        
        if ($propertyNames.Count -gt 0) {
            Write-DebugLog "  [3.5] Available properties: $($propertyNames -join ', ')" "DEBUG"
            
            # Try each possible property name
            $propertyChecks = @('resourceList', 'resources', 'content', 'data', 'items', 'results')
            
            foreach ($propName in $propertyChecks) {
                Write-DebugLog "  [3.6] Checking for property '$propName'..." "DEBUG"
                
                if ($propertyNames -contains $propName) {
                    Write-DebugLog "  [3.6] ✓ Property '$propName' EXISTS" "SUCCESS"
                    
                    try {
                        Write-DebugLog "    [3.7] Attempting to access response.$propName..." "DEBUG"
                        $propValue = $response.$propName
                        
                        if ($null -eq $propValue) {
                            Write-DebugLog "    [3.7] Property '$propName' is NULL" "WARN"
                        }
                        else {
                            Write-DebugLog "    [3.7] ✓ Property '$propName' has value" "SUCCESS"
                            Write-DebugLog "      Type: $($propValue.GetType().Name)" "DEBUG"
                            
                            if ($propValue -is [Array]) {
                                Write-DebugLog "      Is Array: YES" "DEBUG"
                                Write-DebugLog "      Count: $($propValue.Count)" "DEBUG"
                                $allResources = $propValue
                                $dataFound = $true
                                Write-DebugLog "    [3.8] ✓✓✓ FOUND DATA in '$propName'" "SUCCESS"
                                break
                            }
                            else {
                                Write-DebugLog "      Is Array: NO, converting to array" "DEBUG"
                                $allResources = @($propValue)
                                $dataFound = $true
                                Write-DebugLog "    [3.8] ✓ FOUND DATA in '$propName' (converted to array)" "SUCCESS"
                                break
                            }
                        }
                    }
                    catch {
                        Write-DebugLog "    [3.7] ERROR accessing '$propName': $($_.Exception.Message)" "ERROR"
                    }
                }
                else {
                    Write-DebugLog "  [3.6] Property '$propName' does not exist" "DEBUG"
                }
            }
        }
        else {
            Write-DebugLog "  [3.5] No properties found in response!" "ERROR"
        }
    }
    
    # Final validation
    Write-DebugLog "  [3.9] Final validation..." "INFO"
    Write-DebugLog "    dataFound: $dataFound" "DEBUG"
    Write-DebugLog "    allResources is null: $($null -eq $allResources)" "DEBUG"
    
    if ($null -ne $allResources) {
        Write-DebugLog "    allResources type: $($allResources.GetType().Name)" "DEBUG"
        if ($allResources -is [Array]) {
            Write-DebugLog "    allResources count: $($allResources.Count)" "DEBUG"
        }
    }
    
    if (-not $dataFound) {
        Write-DebugLog "  [3.9] ✗✗✗ FAILED TO FIND RESOURCE DATA!" "ERROR"
        Write-DebugLog "  Could not locate VM data in any expected property" "ERROR"
        Write-DebugLog "  Dumping full response for analysis..." "ERROR"
        
        try {
            $fullJson = $response | ConvertTo-Json -Depth 10 -Compress
            Write-DebugLog "================================================================" "ERROR"
            Write-DebugLog "FULL RESPONSE JSON:" "ERROR"
            Write-DebugLog $fullJson "ERROR"
            Write-DebugLog "================================================================" "ERROR"
        }
        catch {
            Write-DebugLog "  Cannot convert to JSON: $($_.Exception.Message)" "ERROR"
            Write-DebugLog "  Response ToString(): $($response.ToString())" "ERROR"
        }
        
        throw "Cannot locate resource data in Aria Operations response"
    }
    
    if ($null -eq $allResources) {
        Write-DebugLog "  [3.9] allResources is NULL, initializing to empty array" "WARN"
        $allResources = @()
    }
    
    if ($allResources -isnot [Array]) {
        Write-DebugLog "  [3.10] allResources is not array, converting..." "WARN"
        $allResources = @($allResources)
    }
    
    Write-DebugLog "  [3.11] ✓✓✓ Step 3 completed successfully" "SUCCESS"
    Write-DebugLog "  Final allResources count: $($allResources.Count)" "SUCCESS"
            }

    
    # Filter for VMs created in timeframe and get identifiers
    $vmIdentifiers = $allResources | Where-Object { 
        $_.creationTime -ge $yesterday 
    } | Select-Object -ExpandProperty identifier
    
    Write-DebugLog "Total VMs in Aria Ops: $($allResources.Count)" "DEBUG"
    Write-DebugLog "VMs created in the last $daysBack day(s): $($vmIdentifiers.Count)" "SUCCESS"
    
    # Get properties for each VM
    foreach ($identifier in $vmIdentifiers) {
        $vmPropertiesURL = "https://$ariaOpsServer/suite-api/api/resources/$identifier/properties?_no_links=true"
        
        try {
            $response = Invoke-RestMethod -Uri $vmPropertiesURL -Headers $ariaHeaders -Method Get
            
            # Extract VM name
            $vmName = $null
            $nameProp = $response.property | Where-Object { $_.name -eq "config|name" -or $_.name -eq "summary|config|name" } | Select-Object -First 1
            if ($nameProp) {
                $vmName = $nameProp.value
            }
            
            if (-not $vmName) {
                Write-DebugLog "  Skipping VM $identifier - no name found" "WARN"
                continue
            }
            
            # Get health status - with null checks
            $status = "Decomm/Offline"  # Default status
            
            # Try to get health badge
            $healthProp = $response.property | Where-Object { $_.name -eq "badge|health" -or $_.name -eq "summary|health" } | Select-Object -First 1
            
            if ($healthProp -and $healthProp.value) {
                try {
                    $healthValue = $healthProp.value.ToString().ToUpper()
                    if ($healthValue -in @("GREEN", "YELLOW", "ORANGE", "RED")) {
                        $status = "Online"
                    }
                    Write-DebugLog "  VM: $vmName | Health: $healthValue | Status: $status" "DEBUG"
                }
                catch {
                    Write-DebugLog "  VM: $vmName | Could not parse health value" "WARN"
                }
            }
            else {
                # Try resource state as fallback
                $resourceStateProp = $response.property | Where-Object { $_.name -eq "summary|resourceState" } | Select-Object -First 1
                
                if ($resourceStateProp -and $resourceStateProp.value) {
                    try {
                        $resourceState = $resourceStateProp.value.ToString().ToUpper()
                        if ($resourceState -in @("STARTED", "MAINTAINED")) {
                            $status = "Online"
                        }
                        Write-DebugLog "  VM: $vmName | Resource State: $resourceState | Status: $status" "DEBUG"
                    }
                    catch {
                        Write-DebugLog "  VM: $vmName | Could not parse resource state" "WARN"
                    }
                }
                else {
                    Write-DebugLog "  VM: $vmName | No health or state data - defaulting to: $status" "WARN"
                }
            }
            
            $newVMsData += [PSCustomObject]@{
                Name = $vmName
                Status = $status
                ResourceId = $identifier
            }
            
            Write-DebugLog "  Added VM: $vmName | Status: $status"
        }
        catch {
            Write-DebugLog "  Error getting properties for VM $identifier : $($_.Exception.Message)" "WARN"
        }
    }
    
    Write-DebugLog "Successfully retrieved $($newVMsData.Count) new VMs from Aria Operations" "SUCCESS"
}
catch {
    Write-DebugLog "Failed to query Aria Operations: $($_.Exception.Message)" "ERROR"
    exit
}

if ($newVMsData.Count -eq 0) {
    Write-DebugLog "`nNo new VMs found in Aria Operations. Exiting." "WARN"
    exit
}

# Connect to vRA and Get Deployment Info
Write-DebugLog "`n===== Processing vRA Servers =====" "INFO"
$deploymentData = @{}

foreach ($vraServer in $vraServers) {
    Write-DebugLog "`n--- Connecting to vRA $vraServer ---" "INFO"
    
    try {
        # Authenticate to vRA
        $vraAuthUri = "https://$vraServer/csp/gateway/am/api/login"
        $vraAuthBody = @{
            username = $username
            password = $password
        } | ConvertTo-Json
        
        $vraAuthResponse = Invoke-RestMethod -Uri $vraAuthUri -Method Post -Headers @{"Content-Type"="application/json"} -Body $vraAuthBody -ErrorAction Stop
        $vraToken = $vraAuthResponse.cspAuthToken
        Write-DebugLog "Authenticated to $vraServer successfully" "SUCCESS"
        
        $vraHeaders = @{
            "Authorization" = "Bearer $vraToken"
            "Content-Type" = "application/json"
        }
        
        # Fetch active deployments
        Write-DebugLog "Fetching active deployments from $vraServer..."
        $vraUri = "https://$vraServer/deployment/api/deployments"
        $page = 0
        $size = 1000
        $allDeployments = @()
        
        do {
            $pagedUri = "$vraUri`?page=$page&size=$size&expand=resources"
            $vraResponse = Invoke-RestMethod -Uri $pagedUri -Method Get -Headers $vraHeaders -ErrorAction Stop
            $deployments = if ($vraResponse.content) { $vraResponse.content } else { $vraResponse }
            
            Write-DebugLog "  Retrieved $($deployments.Count) active deployments on page $($page + 1)"
            $allDeployments += $deployments
            
            $page++
            $hasMore = ($deployments.Count -eq $size)
            
        } while ($hasMore -and $allDeployments.Count -lt 10000)
        
        Write-DebugLog "Total active deployments retrieved: $($allDeployments.Count)"
        
        # Process active deployments
        foreach ($dep in $allDeployments) {
            if ($dep.resources) {
                $vSphereMachines = $dep.resources | Where-Object { $_.type -eq "Cloud.vSphere.Machine" }
                
                foreach ($machine in $vSphereMachines) {
                    $hostname = $null
                    
                    if ($machine.properties) {
                        $props = $machine.properties
                        if ($props.hostname) { $hostname = $props.hostname }
                        elseif ($props.resourceName) { $hostname = $props.resourceName }
                        elseif ($props.name) { $hostname = $props.name }
                        elseif ($props.address) { $hostname = $props.address }
                    }
                    
                    if (-not $hostname -and $machine.name) {
                        $hostname = $machine.name
                    }
                    
                    if ($hostname -and -not $deploymentData.ContainsKey($hostname)) {
                        $vraServerShort = ($vraServer -split '\.')[0]
                        
                        $catalogItem = "N/A"
                        if ($dep.inputs -and $dep.inputs._catalogItemName) {
                            $catalogItem = $dep.inputs._catalogItemName
                        }
                        
                        $deploymentData[$hostname] = @{
                            DeploymentName = $dep.name
                            RequestedBy = if ($dep.createdBy) { $dep.createdBy } else { "N/A" }
                            Requestor = if ($dep.ownedBy) { $dep.ownedBy } else { $dep.createdBy }
                            vRAServer = $vraServerShort
                            CatalogItem = $catalogItem
                            Status = $dep.status
                        }
                        
                        Write-DebugLog "    Stored deployment for $hostname from $vraServer"
                    }
                }
            }
        }
        
        # Fetch deleted deployments
        Write-DebugLog "Searching for deleted deployments from $vraServer..."
        $deletedVMs = Get-DeletedDeploymentVMs -VraServer $vraServer -Headers $vraHeaders -DaysBack $deletedDaysBack
        
        # Merge deleted VMs into deployment data
        foreach ($vmName in $deletedVMs.Keys) {
            if (-not $deploymentData.ContainsKey($vmName)) {
                $vraServerShort = ($vraServer -split '\.')[0]
                $deletedInfo = $deletedVMs[$vmName]
                
                $deploymentData[$vmName] = @{
                    DeploymentName = $deletedInfo.DeploymentName
                    RequestedBy = $deletedInfo.RequestedBy
                    Requestor = $deletedInfo.Requestor
                    vRAServer = $vraServerShort
                    CatalogItem = $deletedInfo.CatalogItem
                    Status = "DELETED"
                }
                
                Write-DebugLog "    Added deleted deployment data for $vmName"
            }
        }
        
        Write-DebugLog "Completed scanning $vraServer" "SUCCESS"
    }
    catch {
        Write-DebugLog "Error processing vRA server $vraServer : $($_.Exception.Message)" "ERROR"
    }
}

Write-DebugLog "`nTotal unique deployments found across all vRA servers: $($deploymentData.Count)" "SUCCESS"

# Connect to vCenter for VMs not found in vRA
Write-DebugLog "`n===== Connecting to vCenter for Additional Info =====" "INFO"
$vCenterLookup = @{}

$vmsNeedingVCenterLookup = @()
foreach ($vmData in $newVMsData) {
    if (-not $deploymentData.ContainsKey($vmData.Name)) {
        $vmsNeedingVCenterLookup += $vmData.Name
    }
}

Write-DebugLog "VMs not found in vRA that need vCenter lookup: $($vmsNeedingVCenterLookup.Count)"

if ($vmsNeedingVCenterLookup.Count -gt 0) {
    foreach ($vCenter in $vCenters) {
        Write-DebugLog "`n--- Connecting to vCenter: $vCenter ---" "INFO"
        
        try {
            $vcConnection = Connect-VIServer -Server $vCenter -Credential $credential -ErrorAction Stop
            Write-DebugLog "Connected to $vCenter successfully" "SUCCESS"
            
            $cutoffDate = (Get-Date).AddDays(-$daysBack)
            $events = Get-VIEvent -Server $vCenter -Start $cutoffDate -MaxSamples 50000 -ErrorAction Stop | Where-Object {
                $_.GetType().Name -in @('VmCreatedEvent', 'VmBeingDeployedEvent', 'VmRegisteredEvent', 'VmDeployedEvent') -and
                $_.Vm.Name -in $vmsNeedingVCenterLookup
            }
            
            Write-DebugLog "Found $($events.Count) relevant creation events in $vCenter"
            
            foreach ($event in $events) {
                $vmName = $event.Vm.Name
                
                if (-not $vCenterLookup.ContainsKey($vmName)) {
                    $vCenterShort = ($vCenter -split '\.')[0]
                    
                    $vCenterLookup[$vmName] = @{
                        CreatedBy = if ($event.UserName) { $event.UserName } else { "N/A" }
                        vCenter = $vCenterShort
                    }
                    
                    Write-DebugLog "  Found creator for $vmName : $($vCenterLookup[$vmName].CreatedBy)"
                }
            }
            
            Disconnect-VIServer -Server $vCenter -Confirm:$false -ErrorAction SilentlyContinue
        }
        catch {
            Write-DebugLog "Error connecting to vCenter $vCenter : $($_.Exception.Message)" "ERROR"
        }
    }
}

# Build Final Report
Write-DebugLog "`n===== Building Final Report =====" "INFO"
$reportData = @()

foreach ($vmData in $newVMsData) {
    $vmName = $vmData.Name
    $depInfo = $null
    
    if ($deploymentData.ContainsKey($vmName)) {
        $depInfo = $deploymentData[$vmName]
    }
    
    if ($depInfo) {
        Write-DebugLog "Matched VM '$vmName' to vRA deployment: $($depInfo.DeploymentName)"
        
        $finalStatus = $vmData.Status
        if ($depInfo.Status -eq "DELETED") {
            $finalStatus = "Decomm/Offline"
        }
        
        $reportData += [PSCustomObject]@{
            Name = $vmName
            Status = $finalStatus
            DeploymentName = $depInfo.DeploymentName
            CatalogItem = $depInfo.CatalogItem
            RequestedBy = $depInfo.RequestedBy
            Requestor = $depInfo.Requestor
            Source = $depInfo.vRAServer
        }
    }
    else {
        Write-DebugLog "No vRA deployment found for VM: $vmName" "WARN"
        
        $vcInfo = if ($vCenterLookup.ContainsKey($vmName)) { $vCenterLookup[$vmName] } else { $null }
        
        if ($vcInfo) {
            $reportData += [PSCustomObject]@{
                Name = $vmName
                Status = $vmData.Status
                DeploymentName = "N/A"
                CatalogItem = "N/A"
                RequestedBy = $vcInfo.CreatedBy
                Requestor = $vcInfo.CreatedBy
                Source = $vcInfo.vCenter
            }
        }
        else {
            $reportData += [PSCustomObject]@{
                Name = $vmName
                Status = $vmData.Status
                DeploymentName = "N/A"
                CatalogItem = "N/A"
                RequestedBy = "N/A"
                Requestor = "N/A"
                Source = "Unknown"
            }
        }
    }
}

# Export to CSV
Write-DebugLog "`n===== Exporting Data =====" "INFO"
$reportData | Select-Object Name, Status, Source, RequestedBy, Requestor, DeploymentName, CatalogItem | Export-Csv -Path $outputCSV -NoTypeInformation
Write-DebugLog "Exported to: $outputCSV" "SUCCESS"

# Send Email Report
Write-DebugLog "`n===== Sending Email Report =====" "INFO"
Send-NewServerReport `
    -ReportData $reportData `
    -SmtpServer $smtpServer `
    -SmtpPort $smtpPort `
    -From $smtpFrom `
    -To $smtpTo `
    -Subject $smtpSubject `
    -DaysBack $daysBack `
    -CsvPath $outputCSV

# Cleanup
Write-DebugLog "`n===== Script Completed Successfully =====" "SUCCESS"
Write-DebugLog "Results saved to: $outputCSV"
Write-DebugLog "Log saved to: $outputLog"
