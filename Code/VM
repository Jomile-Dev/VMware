# New Server Tracker - vCenter + Aria Operations + Multi-vRA
# PowerShell 5.1 Compatible
# Tracks servers built in the last day and correlates with vRA deployments

#region Configuration Variables
$vcServer = "vcenter.yourdomain.com"
$ariaOpsServer = "aria-ops.yourdomain.com"
$vraServers = @(
    "vra1.yourdomain.com",
    "vra2.yourdomain.com"
)

# SMTP Configuration
$smtpServer = "smtp.yourdomain.com"
$smtpPort = 587
$smtpFrom = "vra-reports@yourdomain.com"
$smtpTo = @("admin@yourdomain.com")
$smtpSubject = "New Server Deployment Report - $(Get-Date -Format 'yyyy-MM-dd')"

# Time range for new VMs (in days)
$daysBack = 1

# Output
$outputPath = "C:\Logs\NewServers_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
$debugLog = "C:\Logs\NewServers_Debug_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
#endregion

#region Helper Functions
function Write-DebugLog {
    param(
        [string]$Message, 
        [string]$Level = "INFO"
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] [$Level] $Message"
    
    $color = "Cyan"
    switch ($Level) {
        "ERROR" { $color = "Red" }
        "WARN" { $color = "Yellow" }
        "SUCCESS" { $color = "Green" }
    }
    
    Write-Host $logMessage -ForegroundColor $color
    Add-Content -Path $debugLog -Value $logMessage
}

function Disable-SSLValidation {
    if (-not ([System.Management.Automation.PSTypeName]'TrustAllCertsPolicy').Type) {
        Add-Type @"
        using System.Net;
        using System.Security.Cryptography.X509Certificates;
        public class TrustAllCertsPolicy : ICertificatePolicy {
            public bool CheckValidationResult(
                ServicePoint svcPoint, X509Certificate certificate,
                WebRequest request, int certificateProblem) {
                return true;
            }
        }
"@
        [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
    }
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
}
#endregion

#region Main Script
try {
    Write-DebugLog "===== Script Started =====" "SUCCESS"
    Write-DebugLog "PowerShell Version: $($PSVersionTable.PSVersion)"
    Write-DebugLog "Output CSV: $outputPath"
    Write-DebugLog "Debug Log: $debugLog"
    
    # Ensure log directory exists
    $logDir = Split-Path $outputPath -Parent
    if (!(Test-Path $logDir)) {
        New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        Write-DebugLog "Created log directory: $logDir"
    }
    
    Disable-SSLValidation
    Write-DebugLog "SSL validation disabled"
    
    # Get credentials once for all connections
    Write-DebugLog "Requesting credentials..."
    $credential = Get-Credential -Message "Enter credentials for vCenter, Aria Operations, and vRA"
    if (-not $credential) {
        Write-DebugLog "Credentials not provided. Exiting." "ERROR"
        return
    }
    $username = $credential.UserName
    $password = $credential.GetNetworkCredential().Password
    Write-DebugLog "Credentials obtained for user: $username"
    
    #region Connect to vCenter
    Write-DebugLog "`n===== Connecting to vCenter =====" "INFO"
    try {
        # Try to import VMware module
        $vmwareModule = Get-Module -Name VMware.VimAutomation.Core -ListAvailable | Select-Object -First 1
        if ($vmwareModule) {
            Import-Module VMware.VimAutomation.Core -ErrorAction Stop
            Write-DebugLog "VMware PowerCLI module loaded (Version: $($vmwareModule.Version))"
        }
        else {
            Write-DebugLog "CRITICAL: VMware PowerCLI not installed. Install with: Install-Module VMware.PowerCLI -Scope CurrentUser" "ERROR"
            throw "VMware PowerCLI not found"
        }
    }
    catch {
        Write-DebugLog "Error loading VMware module: $($_.Exception.Message)" "ERROR"
        throw
    }
    
    # Suppress certificate warnings for PowerCLI
    $null = Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session
    $null = Set-PowerCLIConfiguration -ParticipateInCeip $false -Confirm:$false -Scope Session
    
    Write-DebugLog "Connecting to vCenter: $vcServer"
    $vcConnection = Connect-VIServer -Server $vcServer -Credential $credential -ErrorAction Stop
    Write-DebugLog "Connected to vCenter successfully" "SUCCESS"
    
    # Get VMs created in the last X days
    $cutoffDate = (Get-Date).AddDays(-$daysBack)
    Write-DebugLog "Searching for VMs created after: $cutoffDate"
    
    $allVMs = Get-VM
    Write-DebugLog "Total VMs in vCenter: $($allVMs.Count)"
    
    $newVMs = $allVMs | Where-Object { 
        $_.CreateDate -gt $cutoffDate 
    }
    
    Write-DebugLog "Found $($newVMs.Count) VMs created in the last $daysBack day(s)" "SUCCESS"
    
    if ($newVMs.Count -eq 0) {
        Write-DebugLog "No new VMs found. Exiting." "WARN"
        Disconnect-VIServer -Server $vcServer -Confirm:$false
        return
    }
    
    foreach ($vm in $newVMs) {
        Write-DebugLog "  - $($vm.Name) | PowerState: $($vm.PowerState) | Created: $($vm.CreateDate)"
    }
    #endregion
    
    #region Connect to Aria Operations
    Write-DebugLog "`n===== Connecting to Aria Operations =====" "INFO"
    $ariaToken = $null
    $vmStatusMap = @{}
    
    try {
        Write-DebugLog "Authenticating to Aria Operations: $ariaOpsServer"
        $ariaAuthUri = "https://$ariaOpsServer/suite-api/api/auth/token/acquire"
        $ariaAuthBody = @{
            username = $username
            password = $password
        } | ConvertTo-Json
        
        $ariaAuthHeaders = @{
            "Content-Type" = "application/json"
            "Accept" = "application/json"
        }
        
        $ariaAuthResponse = Invoke-RestMethod -Uri $ariaAuthUri -Method Post -Headers $ariaAuthHeaders -Body $ariaAuthBody -ErrorAction Stop
        $ariaToken = $ariaAuthResponse.token
        Write-DebugLog "Authenticated to Aria Operations successfully" "SUCCESS"
        
        $ariaHeaders = @{
            "Authorization" = "vRealizeOpsToken $ariaToken"
            "Content-Type" = "application/json"
            "Accept" = "application/json"
        }
        
        # Get VM status from Aria Operations for each new VM
        Write-DebugLog "Querying VM status from Aria Operations..."
        foreach ($vm in $newVMs) {
            try {
                $vmName = $vm.Name
                Write-DebugLog "  Checking status for: $vmName"
                
                # Search for the VM resource in Aria Operations
                $escapedVmName = [uri]::EscapeDataString($vmName)
                $searchUri = "https://$ariaOpsServer/suite-api/api/resources?name=$escapedVmName&resourceKind=VirtualMachine"
                $searchResponse = Invoke-RestMethod -Uri $searchUri -Method Get -Headers $ariaHeaders -ErrorAction Stop
                
                if ($searchResponse.resourceList -and $searchResponse.resourceList.Count -gt 0) {
                    $resource = $searchResponse.resourceList[0]
                    $resourceId = $resource.identifier
                    
                    # Get resource health/status
                    $statusUri = "https://$ariaOpsServer/suite-api/api/resources/$resourceId"
                    $statusResponse = Invoke-RestMethod -Uri $statusUri -Method Get -Headers $ariaHeaders -ErrorAction Stop
                    
                    $healthState = $statusResponse.resourceStatusStates | Where-Object { $_.resourceState -eq "HEALTH" } | Select-Object -First 1
                    $status = if ($healthState) { $healthState.status } else { "UNKNOWN" }
                    
                    # Map status to simple online/offline/decomm
                    $simpleStatus = "Unknown"
                    switch ($status) {
                        "GREEN" { $simpleStatus = "Online" }
                        "YELLOW" { $simpleStatus = "Online" }
                        "ORANGE" { $simpleStatus = "Online" }
                        "RED" { $simpleStatus = "Offline" }
                        "GREY" { $simpleStatus = "Decomm/Offline" }
                    }
                    
                    $vmStatusMap[$vmName] = $simpleStatus
                    Write-DebugLog "    Status: $simpleStatus ($status)"
                }
                else {
                    Write-DebugLog "    VM not found in Aria Operations, using vCenter PowerState" "WARN"
                    if ($vm.PowerState -eq "PoweredOn") {
                        $vmStatusMap[$vmName] = "Online"
                    } else {
                        $vmStatusMap[$vmName] = "Offline"
                    }
                }
            }
            catch {
                Write-DebugLog "    Error checking Aria Ops status: $($_.Exception.Message)" "WARN"
                if ($vm.PowerState -eq "PoweredOn") {
                    $vmStatusMap[$vmName] = "Online"
                } else {
                    $vmStatusMap[$vmName] = "Offline"
                }
            }
        }
    }
    catch {
        Write-DebugLog "Failed to connect to Aria Operations: $($_.Exception.Message)" "WARN"
        Write-DebugLog "Will use vCenter PowerState for VM status" "WARN"
        
        # Fallback to vCenter PowerState
        foreach ($vm in $newVMs) {
            if ($vm.PowerState -eq "PoweredOn") {
                $vmStatusMap[$vm.Name] = "Online"
            } else {
                $vmStatusMap[$vm.Name] = "Offline"
            }
        }
    }
    #endregion
    
    #region Connect to vRA and Get Deployment Info
    Write-DebugLog "`n===== Processing vRA Servers =====" "INFO"
    $deploymentData = @{}
    
    foreach ($vraServer in $vraServers) {
        Write-DebugLog "`n--- Connecting to vRA: $vraServer ---" "INFO"
        
        try {
            # Authenticate to vRA
            Write-DebugLog "Authenticating to $vraServer..."
            $vraAuthUri = "https://$vraServer/csp/gateway/am/api/login"
            $vraAuthBody = @{
                username = $username
                password = $password
            } | ConvertTo-Json
            
            $vraAuthHeaders = @{
                "Content-Type" = "application/json"
                "Accept" = "application/json"
            }
            
            $vraAuthResponse = Invoke-RestMethod -Uri $vraAuthUri -Method Post -Headers $vraAuthHeaders -Body $vraAuthBody -ErrorAction Stop
            $vraToken = $vraAuthResponse.cspAuthToken
            Write-DebugLog "Authenticated to $vraServer successfully" "SUCCESS"
            
            $vraHeaders = @{
                "Authorization" = "Bearer $vraToken"
                "Content-Type" = "application/json"
            }
            
            # Fetch deployments
            Write-DebugLog "Fetching deployments from $vraServer..."
            $vraUri = "https://$vraServer/deployment/api/deployments"
            $page = 0
            $size = 1000
            $deploymentsFound = 0
            
            do {
                $pagedUri = "$vraUri`?page=$page&size=$size&expand=resources"
                Write-DebugLog "  Fetching page $($page + 1) (size: $size)..."
                
                $vraResponse = Invoke-RestMethod -Uri $pagedUri -Method Get -Headers $vraHeaders -ErrorAction Stop
                if ($vraResponse.content) {
                    $deployments = $vraResponse.content
                } else {
                    $deployments = $vraResponse
                }
                
                Write-DebugLog "  Retrieved $($deployments.Count) deployments on page $($page + 1)"
                
                # Filter for deployments with vSphere machines
                $deploymentsWithVMs = @()
                foreach ($dep in $deployments) {
                    if ($dep.resources) {
                        $hasVSphereMachine = $false
                        foreach ($res in $dep.resources) {
                            if ($res.type -eq "Cloud.vSphere.Machine") {
                                $hasVSphereMachine = $true
                                break
                            }
                        }
                        if ($hasVSphereMachine) {
                            $deploymentsWithVMs += $dep
                        }
                    }
                }
                
                Write-DebugLog "  $($deploymentsWithVMs.Count) deployments have vSphere machines"
                
                foreach ($dep in $deploymentsWithVMs) {
                    $vSphereMachines = @()
                    foreach ($res in $dep.resources) {
                        if ($res.type -eq "Cloud.vSphere.Machine") {
                            $vSphereMachines += $res
                        }
                    }
                    
                    foreach ($machine in $vSphereMachines) {
                        # Get hostname from various possible properties
                        $hostname = $null
                        if ($machine.properties.hostname) { 
                            $hostname = $machine.properties.hostname 
                        } elseif ($machine.properties.resourceName) {
                            $hostname = $machine.properties.resourceName
                        } elseif ($machine.name) {
                            $hostname = $machine.name
                        }
                        
                        if ($hostname) {
                            # Store deployment info for this machine
                            if (-not $deploymentData.ContainsKey($hostname)) {
                                $deploymentsFound++
                                
                                $description = "N/A"
                                if ($dep.description) { $description = $dep.description }
                                
                                $requestedBy = "N/A"
                                if ($dep.createdBy) { $requestedBy = $dep.createdBy }
                                
                                $requestor = $requestedBy
                                if ($dep.ownedBy) { $requestor = $dep.ownedBy }
                                
                                $deploymentData[$hostname] = @{
                                    DeploymentName = $dep.name
                                    Description = $description
                                    RequestedBy = $requestedBy
                                    Requestor = $requestor
                                    vRAServer = $vraServer
                                    DeploymentID = $dep.id
                                    Status = $dep.status
                                }
                            }
                        }
                    }
                }
                
                $page++
                $hasMore = $false
                
                if ($vraResponse.totalPages) { 
                    $hasMore = ($page -lt $vraResponse.totalPages)
                } elseif ($vraResponse.totalElements) { 
                    $hasMore = (($page * $size) -lt $vraResponse.totalElements)
                } else { 
                    $hasMore = ($deployments.Count -eq $size)
                }
                
            } while ($hasMore)
            
            Write-DebugLog "Completed scanning $vraServer - Found $deploymentsFound deployments" "SUCCESS"
        }
        catch {
            Write-DebugLog "Error processing vRA server $vraServer`: $($_.Exception.Message)" "ERROR"
            Write-DebugLog "Error details: $($_.Exception)" "ERROR"
        }
    }
    
    Write-DebugLog "`nTotal unique deployments found across all vRA servers: $($deploymentData.Count)" "SUCCESS"
    #endregion
    
    #region Build Final Report
    Write-DebugLog "`n===== Building Final Report =====" "INFO"
    $reportData = @()
    
    foreach ($vm in $newVMs) {
        $vmName = $vm.Name
        $vmStatus = $vmStatusMap[$vmName]
        
        # Try to find deployment info
        $depInfo = $null
        if ($deploymentData.ContainsKey($vmName)) {
            $depInfo = $deploymentData[$vmName]
        }
        
        if ($depInfo) {
            Write-DebugLog "Matched VM '$vmName' to deployment: $($depInfo.DeploymentName)"
        }
        else {
            Write-DebugLog "No deployment found for VM: $vmName" "WARN"
        }
        
        $reportObject = New-Object PSObject -Property @{
            Name = $vmName
            Status = $vmStatus
            CreatedDate = $vm.CreateDate
            DeploymentName = if ($depInfo) { $depInfo.DeploymentName } else { "Not Found" }
            Description = if ($depInfo) { $depInfo.Description } else { "N/A" }
            RequestedBy = if ($depInfo) { $depInfo.RequestedBy } else { "N/A" }
            Requestor = if ($depInfo) { $depInfo.Requestor } else { "N/A" }
            vRAServer = if ($depInfo) { $depInfo.vRAServer } else { "N/A" }
            DeploymentStatus = if ($depInfo) { $depInfo.Status } else { "N/A" }
        }
        
        $reportData += $reportObject
    }
    
    Write-DebugLog "Report contains $($reportData.Count) records" "SUCCESS"
    #endregion
    
    #region Export to CSV
    Write-DebugLog "`n===== Exporting Data =====" "INFO"
    # Select properties in specific order for CSV
    $reportData | Select-Object Name, Status, CreatedDate, DeploymentName, Description, RequestedBy, Requestor, vRAServer, DeploymentStatus | Export-Csv -Path $outputPath -NoTypeInformation
    Write-DebugLog "Exported to: $outputPath" "SUCCESS"
    #endregion
    
    #region Send Email
    Write-DebugLog "`n===== Sending Email Report =====" "INFO"
    try {
        Write-DebugLog "Requesting SMTP credentials..."
        $smtpCredential = Get-Credential -Message "Enter SMTP credentials"
        
        if (-not $smtpCredential) {
            Write-DebugLog "SMTP credentials not provided. Skipping email." "WARN"
        }
        else {
            # Build HTML table for email
            $htmlRows = ""
            foreach ($record in $reportData) {
                $htmlRows += "<tr>"
                $htmlRows += "<td>$($record.Name)</td>"
                $htmlRows += "<td>$($record.Status)</td>"
                $htmlRows += "<td>$($record.CreatedDate)</td>"
                $htmlRows += "<td>$($record.DeploymentName)</td>"
                $htmlRows += "<td>$($record.Description)</td>"
                $htmlRows += "<td>$($record.RequestedBy)</td>"
                $htmlRows += "<td>$($record.Requestor)</td>"
                $htmlRows += "<td>$($record.vRAServer)</td>"
                $htmlRows += "</tr>"
            }
            
            $htmlTable = @"
<table>
<thead>
<tr>
<th>Name</th>
<th>Status</th>
<th>Created Date</th>
<th>Deployment Name</th>
<th>Description</th>
<th>Requested By</th>
<th>Requestor</th>
<th>vRA Server</th>
</tr>
</thead>
<tbody>
$htmlRows
</tbody>
</table>
"@
            
            $currentDate = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
            $htmlBody = @"
<html>
<head>
<style>
    body { font-family: Arial, sans-serif; }
    table { border-collapse: collapse; width: 100%; }
    th { background-color: #4CAF50; color: white; padding: 8px; text-align: left; }
    td { border: 1px solid #ddd; padding: 8px; }
    tr:nth-child(even) { background-color: #f2f2f2; }
</style>
</head>
<body>
<h2>New Server Deployment Report</h2>
<p>Generated: $currentDate</p>
<p>Total New Servers: $($reportData.Count)</p>
$htmlTable
<p><small>CSV attached for detailed analysis.</small></p>
</body>
</html>
"@
            
            Write-DebugLog "Sending email to: $($smtpTo -join ', ')"
            Send-MailMessage `
                -From $smtpFrom `
                -To $smtpTo `
                -Subject $smtpSubject `
                -Body $htmlBody `
                -BodyAsHtml `
                -SmtpServer $smtpServer `
                -Port $smtpPort `
                -UseSsl `
                -Credential $smtpCredential `
                -Attachments $outputPath `
                -ErrorAction Stop
            
            Write-DebugLog "Email sent successfully!" "SUCCESS"
        }
    }
    catch {
        Write-DebugLog "Failed to send email: $($_.Exception.Message)" "ERROR"
        if ($_.Exception.InnerException) {
            Write-DebugLog "Email error details: $($_.Exception.InnerException)" "ERROR"
        }
    }
    #endregion
    
    #region Cleanup
    Write-DebugLog "`n===== Cleanup =====" "INFO"
    if ($vcConnection) {
        Disconnect-VIServer -Server $vcServer -Confirm:$false
        Write-DebugLog "Disconnected from vCenter"
    }
    
    Write-DebugLog "`n===== Script Completed Successfully =====" "SUCCESS"
    Write-DebugLog "Results saved to: $outputPath"
    Write-DebugLog "Debug log saved to: $debugLog"
    #endregion
}
catch {
    Write-DebugLog "`n===== CRITICAL ERROR =====" "ERROR"
    Write-DebugLog "Error: $($_.Exception.Message)" "ERROR"
    if ($_.ScriptStackTrace) {
        Write-DebugLog "Stack Trace: $($_.ScriptStackTrace)" "ERROR"
    }
    if ($_.InvocationInfo.ScriptLineNumber) {
        Write-DebugLog "Line: $($_.InvocationInfo.ScriptLineNumber)" "ERROR"
    }
    throw
}
finally {
    # Final cleanup
    if ($vcConnection) {
        try { 
            Disconnect-VIServer -Server * -Confirm:$false -ErrorAction SilentlyContinue 
        } catch {
            # Suppress any cleanup errors
        }
    }
}
#endregion
