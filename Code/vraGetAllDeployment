# VMware Aria Automation - Export Deployments with vSphere Machines
# Exports only deployments that contain Cloud.vSphere.Machine resources

$vraServer = "vra.yourdomain.com"
$outputPath = "C:\Logs\vRA_Deployments_Export_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"

function Write-Log {
    param($Message, $Color = "White")
    Write-Host $Message -ForegroundColor $Color
}

# Disable SSL validation
if (-not ([System.Management.Automation.PSTypeName]'TrustAllCertsPolicy').Type) {
    Add-Type @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(
            ServicePoint svcPoint, X509Certificate certificate,
            WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@
    [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Authenticate
Write-Log "=== AUTHENTICATION ===" -Color Cyan
$credential = Get-Credential -Message "Enter VMware Aria Automation credentials"
$username = $credential.UserName
$password = $credential.GetNetworkCredential().Password

$uri = "https://$vraServer/csp/gateway/am/api/login"
$body = @{
    username = $username
    password = $password
} | ConvertTo-Json

$authHeaders = @{
    "Content-Type" = "application/json"
    "Accept" = "application/json"
}

$response = Invoke-RestMethod -Uri $uri -Method Post -Headers $authHeaders -Body $body
$token = $response.cspAuthToken
Write-Log "Authentication successful!`n" -Color Green

$headers = @{
    "Authorization" = "Bearer $token"
    "Content-Type" = "application/json"
}

# Get all deployments with pagination and filter as we go
Write-Log "=== FETCHING DEPLOYMENTS ===" -Color Cyan
$uri = "https://$vraServer/deployment/api/deployments"
$exportData = @()
$page = 0
$size = 500
$totalProcessed = 0
$foundCount = 0
$skippedCount = 0

do {
    $pagedUri = "$uri`?page=$page&size=$size&expand=resources"
    Write-Log "  Fetching page $($page + 1)..." -Color Gray
    
    try {
        $response = Invoke-RestMethod -Uri $pagedUri -Method Get -Headers $headers
        $deployments = if ($response.content) { $response.content } else { $response }
        
        # Process each deployment immediately
        foreach ($dep in $deployments) {
            $totalProcessed++
            $vSphereMachines = @()
            
            # Check inline resources for Cloud.vSphere.Machine
            if ($dep.resources) {
                $vSphereMachines = @($dep.resources | Where-Object { $_.type -eq "Cloud.vSphere.Machine" })
            }
            
            # Try separate resource call if needed
            if ($vSphereMachines.Count -eq 0) {
                try {
                    $resourceUri = "https://$vraServer/deployment/api/deployments/$($dep.id)/resources"
                    $separateResources = Invoke-RestMethod -Uri $resourceUri -Method Get -Headers $headers -ErrorAction Stop
                    $resList = if ($separateResources.content) { $separateResources.content } else { $separateResources }
                    $vSphereMachines = @($resList | Where-Object { $_.type -eq "Cloud.vSphere.Machine" })
                } catch {
                    # No resources available
                }
            }
            
            # Only keep deployments with Cloud.vSphere.Machine
            if ($vSphereMachines.Count -gt 0) {
                $foundCount++
                Write-Log "  âœ“ [$foundCount] $($dep.name) - $($vSphereMachines.Count) vSphere machine(s)" -Color Green
                
                foreach ($machine in $vSphereMachines) {
                    # Get hostname from properties
                    $hostname = if ($machine.properties.hostname) { 
                        $machine.properties.hostname 
                    } elseif ($machine.properties.resourceName) {
                        $machine.properties.resourceName
                    } elseif ($machine.name) {
                        $machine.name
                    } else {
                        "N/A"
                    }
                    
                    $exportData += [PSCustomObject]@{
                        DeploymentName = $dep.name
                        DeploymentID = $dep.id
                        ServerName = $hostname
                        ResourceName = $machine.name
                        Status = $dep.status
                        CreatedBy = $dep.createdBy
                        CreatedAt = $dep.createdAt
                        ProjectID = $dep.projectId
                    }
                }
            } else {
                $skippedCount++
            }
        }
        
        Write-Log "  Page summary: Processed $($deployments.Count), Found $foundCount total, Skipped $skippedCount total" -Color Cyan
        
        $page++
        
        # Check if there are more pages
        $hasMore = if ($response.totalPages) { 
            $page -lt $response.totalPages 
        } elseif ($response.totalElements) { 
            $totalProcessed -lt $response.totalElements 
        } else { 
            $deployments.Count -eq $size 
        }
    }
    catch {
        Write-Log "Error fetching page $($page + 1): $($_.Exception.Message)" -Color Red
        break
    }
    
} while ($hasMore)

Write-Log "`nTotal deployments scanned: $totalProcessed" -Color Cyan
Write-Log "Deployments with vSphere machines: $foundCount`n" -Color Green

# Export to CSV
Write-Log "`n=== EXPORTING ===" -Color Cyan
$exportData | Export-Csv -Path $outputPath -NoTypeInformation
Write-Log "Exported $($exportData.Count) server records to:" -Color Green
Write-Log "$outputPath" -Color White

# Summary
Write-Log "`n=== SUMMARY ===" -Color Cyan
Write-Log "Total deployments scanned: $totalProcessed" -Color White
Write-Log "Deployments with Cloud.vSphere.Machine: $foundCount" -Color Green
Write-Log "Deployments skipped (no vSphere machines): $skippedCount" -Color Yellow
Write-Log "Total server records exported: $($exportData.Count)" -Color Cyan
