# ============================================================================
# DELETED VM TRACKER - ARIA OPERATIONS + MULTI-VRA + VCENTER
# Version 2.4.2 - FULL VERSION (All Troubleshooting & Enhanced Logic)
# ============================================================================

# ============================================================================
# CONFIGURATION SECTION
# ============================================================================
$ariaOpsServer = "aria-ops.yourdomain.com"
$ariaOpsDomain = "yourdomain.com"
$ariaOpsAuthSource = "localos"

$vraServers = @("vra1.yourdomain.com", "vra2.yourdomain.com")
$vCenters = @("vcenter1.domain.com", "vcenter2.domain.com", "vcenter3.domain.com")

# EMAIL CONFIGURATION
$script:smtpServer = "smtp.yourdomain.com"
$script:smtpPort = 587
$script:smtpFrom = "vra-reports@yourdomain.com"
$script:smtpTo = @("test.test@email.com")
$script:smtpCc = @("manager@yourdomain.com")
$script:smtpSubject = "VM Lifecycle & Deletion Report - $(Get-Date -Format 'dd-MM-yyyy')"

$daysBack = 1
$eventsPageSize = 200
$deploymentLookbackDays = 30
$debugOutputFile = "DeletedVMs_Debug_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"

# ============================================================================
# HELPER FUNCTIONS (RESTORED)
# ============================================================================
function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $color = switch ($Level) { "ERROR" {"Red"} "WARN" {"Yellow"} "SUCCESS" {"Green"} "DEBUG" {"Magenta"} default {"Cyan"} }
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] [$Level] $Message"
    Write-Host $logMessage -ForegroundColor $color
    Add-Content -Path $debugOutputFile -Value $logMessage
}

function Write-DebugSection { param([string]$Title) $sep = "`n" + ("=" * 80) + "`n"; $h = "$sep$Title$sep"; Write-Host $h -ForegroundColor Cyan; Add-Content -Path $debugOutputFile -Value $h }

function Disable-SSLValidation {
    if (-not ([System.Management.Automation.PSTypeName]'TrustAllCertsPolicy').Type) {
        Add-Type "using System.Net; using System.Security.Cryptography.X509Certificates; public class TrustAllCertsPolicy : ICertificatePolicy { public bool CheckValidationResult(ServicePoint s, X509Certificate c, WebRequest r, int p) { return true; } }"
        [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
    }
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
}

function Convert-ToSydneyTime {
    param([string]$DateTimeString)
    if ([string]::IsNullOrWhiteSpace($DateTimeString) -or $DateTimeString -eq "N/A") { return "N/A" }
    try {
        $utcTime = [DateTime]::Parse($DateTimeString).ToUniversalTime()
        $sydneyTZ = [System.TimeZoneInfo]::FindSystemTimeZoneById("AUS Eastern Standard Time")
        return [System.TimeZoneInfo]::ConvertTimeFromUtc($utcTime, $sydneyTZ).ToString("dd-MM-yyyy HH:mm:ss")
    } catch { return $DateTimeString }
}

function Extract-CloudResourceName {
    param([PSObject]$Event)
    $serverName = $null
    if ($Event.details) {
        $detailsText = if ($Event.details -is [string]) { $Event.details } else { $Event.details | ConvertTo-Json -Compress -Depth 5 }
        if ($detailsText -match "Cloud Resource Name:\s*([^\s,;]+)") { $serverName = $matches[1].Trim() }
        elseif ($detailsText -match '"cloudResourceName"\s*:\s*"([^"]+)"') { $serverName = $matches[1].Trim() }
        elseif ($detailsText -match '"hostname"\s*:\s*"([^"]+)"') { $serverName = $matches[1].Trim() }
    }
    if (-not $serverName -and $Event.resourceName -and $Event.resourceName -notmatch "Cloud_vSphere_Machine_") { $serverName = $Event.resourceName }
    return $serverName
}

function Get-AllEventsForRequest {
    param($VraServer, $Headers, $DeploymentId, $RequestId, [switch]$IncludeDeleted)
    $allEvents = @(); $page = 0; $del = if ($IncludeDeleted) { "&deleted=true" } else { "" }
    do {
        $uri = "https://$VraServer/deployment/api/deployments/$DeploymentId/requests/$RequestId/events?page=$page&size=$eventsPageSize$del&apiVersion=2020-08-25"
        try {
            $res = Invoke-RestMethod -Uri $uri -Method Get -Headers $Headers -ErrorAction Stop
            $events = if ($res.content) { $res.content } else { $res }
            if ($events) { $allEvents += $events; $page++; if ($events.Count -lt $eventsPageSize) { break } } else { break }
        } catch { break }
    } while ($page -lt 20)
    return $allEvents
}

# ============================================================================
# MAIN DATA FUNCTIONS (RESTORED)
# ============================================================================

function Get-ActiveDeploymentsWithDecommission {
    param($VraServer, $Headers)
    Write-DebugSection "Checking Active Deployments with Decommission Requests: $VraServer"
    $decommissionData = New-Object System.Collections.ArrayList
    $cutoffDate = (Get-Date).AddDays(-$deploymentLookbackDays).ToString("yyyy-MM-dd")
    
    $page = 0; $size = 1000
    do {
        $pagedUri = "https://$VraServer/deployment/api/deployments?page=$page&size=$size&expand=resources&`$filter=lastUpdatedAt ge '$cutoffDate'"
        try {
            $response = Invoke-RestMethod -Uri $pagedUri -Method Get -Headers $Headers -ErrorAction Stop
            $deployments = if ($response.content) { $response.content } else { $response }
            if (-not $deployments) { break }
            
            foreach ($dep in $deployments) {
                if ($dep.status -match "DELETE|DECOMMISSION") {
                    # Logic to find the machine name and requestor
                    $vmName = ($dep.resources | Where-Object {$_.type -eq "Cloud.vSphere.Machine"}).name | Select-Object -First 1
                    $decommissionData.Add([PSCustomObject]@{
                        VMName = $vmName; DeploymentName = $dep.name; RequestAction = "Decommission/Delete";
                        RequestStatus = $dep.status; RequestedBy = $dep.ownedBy;
                        InitiatedAt = Convert-ToSydneyTime $dep.createdAt; DeletionDate = Convert-ToSydneyTime $dep.lastUpdatedAt;
                        vRAServer = ($VraServer -split '\.')[0]; DeploymentID = $dep.id; Source = "vRA-Active"
                    }) | Out-Null
                }
            }
            $page++; $hasMore = ($deployments.Count -eq $size)
        } catch { break }
    } while ($hasMore -and $page -lt 20)
    return $decommissionData
}

function Get-FailedDeploymentsFromVRA {
    param($VraServer, $Headers)
    Write-DebugSection "Identifying Failed Builds (vRA Cleanups): $VraServer"
    $failedData = New-Object System.Collections.ArrayList
    
    # We specifically look for CREATE_FAILED to find items vRA deleted itself
    $uri = "https://$VraServer/deployment/api/deployments?expand=resources&`$filter=status eq 'CREATE_FAILED'"
    try {
        $res = Invoke-RestMethod -Uri $uri -Method Get -Headers $Headers -ErrorAction Stop
        $deployments = if ($res.content) { $res.content } else { $res }
        
        foreach ($dep in $deployments) {
            Write-Log "Investigating Failed Deployment: $($dep.name)" "DEBUG"
            $reqUri = "https://$VraServer/deployment/api/deployments/$($dep.id)/requests?apiVersion=2020-08-25"
            $requests = (Invoke-RestMethod -Uri $reqUri -Method Get -Headers $Headers).content
            
            foreach ($r in $requests) {
                # Look for the Provision event to find the name vCenter would have seen
                $events = Get-AllEventsForRequest -VraServer $VraServer -Headers $Headers -DeploymentId $dep.id -RequestId $r.id
                $extractedName = $null
                foreach ($evt in $events) { 
                    $extractedName = Extract-CloudResourceName -Event $evt
                    if ($extractedName) { break } 
                }
                
                if ($extractedName) {
                    $failedData.Add([PSCustomObject]@{
                        VMName = $extractedName; DeploymentName = $dep.name; RequestStatus = "CREATE_FAILED";
                        RequestedBy = $dep.createdBy; InitiatedAt = Convert-ToSydneyTime $dep.createdAt;
                        vRAServer = ($VraServer -split '\.')[0]; Source = "vRA-FailedBuild"
                    }) | Out-Null
                    break
                }
            }
        }
    } catch { Write-Log "Error fetching failed builds: $($_.Exception.Message)" "ERROR" }
    return $failedData
}

function Get-DeletedVMsFromVCenter {
    param($VCenter, $Credential, $DaysBack)
    Write-DebugSection "vCENTER - CHECKING DIRECT VM DELETIONS: $VCenter"
    $deletedVMs = @()
    try {
        Connect-VIServer -Server $VCenter -Credential $Credential -ErrorAction Stop | Out-Null
        $cutoffDate = (Get-Date).AddDays(-$DaysBack)
        $events = Get-VIEvent -Start $cutoffDate -MaxSamples 20000 | Where-Object { $_.GetType().Name -match 'VmRemovedEvent|VmBeingDeletedEvent' }
        
        foreach ($event in $events) {
            $deletedVMs += New-Object PSObject -Property @@{
                VMName = $event.Vm.Name; DeletedAt = Convert-ToSydneyTime $event.CreatedTime.ToString("yyyy-MM-ddTHH:mm:ss");
                DeletedBy = $event.UserName; EventType = $event.GetType().Name; 
                vCenter = ($VCenter -split '\.')[0]; Source = "vCenter-Deleted"
            }
        }
        Disconnect-VIServer -Server $VCenter -Confirm:$false
    } catch { Write-Log "vCenter Error: $($_.Exception.Message)" "ERROR" }
    return $deletedVMs
}

# ============================================================================
# MAIN SCRIPT EXECUTION
# ============================================================================
Disable-SSLValidation
$credential = Get-Credential
$username = $credential.UserName
$password = $credential.GetNetworkCredential().Password

$allDecomm = @(); $allFailed = @(); $allVC = @()

foreach ($srv in $vraServers) {
    try {
        Write-Log "Connecting to vRA: $srv" "DEBUG"
        $authBody = @{ username = $username; password = $password } | ConvertTo-Json
        $auth = Invoke-RestMethod -Uri "https://$srv/csp/gateway/am/api/login" -Method Post -Headers @{"Content-Type"="application/json"} -Body $authBody
        $vraHeaders = @{"Authorization"="Bearer $($auth.cspAuthToken)"; "Content-Type"="application/json"}
        
        $allDecomm += Get-ActiveDeploymentsWithDecommission -VraServer $srv -Headers $vraHeaders
        $allFailed += Get-FailedDeploymentsFromVRA -VraServer $srv -Headers $vraHeaders
    } catch { Write-Log "vRA Connection Failed for $srv" "ERROR" }
}

foreach ($vc in $vCenters) { $allVC += Get-DeletedVMsFromVCenter -VCenter $vc -Credential $credential -DaysBack $daysBack }

# ============================================================================
# MATCHING ENGINE: Link vRA Failed Builds to vCenter Cleanup
# ============================================================================
Write-DebugSection "MATCHING FAILED vRA VMs vs vCenter DELETIONS"
$finalReportList = New-Object System.Collections.ArrayList
$vcMatchedKeys = @{}

foreach ($fVM in $allFailed) {
    # If the failed VM name exists in the vCenter deleted list...
    $match = $allVC | Where-Object { $_.VMName -eq $fVM.VMName } | Select-Object -First 1
    if ($match) {
        Write-Log "MATCH FOUND: vRA Failed Build '$($fVM.VMName)' was deleted by $($match.DeletedBy)" "SUCCESS"
        $fVM.RequestedBy = "vRA (Internal Cleanup/Failed Build)"
        $fVM.RequestStatus = "Build Failed & Deleted"
        $vcMatchedKeys[$match.VMName.ToLower()] = $true
    }
    $finalReportList.Add($fVM) | Out-Null
}

# Add pure vCenter deletions that weren't vRA cleanups
foreach ($vcVM in $allVC) {
    if (-not $vcMatchedKeys.ContainsKey($vcVM.VMName.ToLower())) {
        $finalReportList.Add([PSCustomObject]@{
            VMName = $vcVM.VMName; DeploymentName = "N/A (Direct VC Deletion)";
            RequestStatus = "Deleted"; RequestedBy = $vcVM.DeletedBy;
            InitiatedAt = $vcVM.DeletedAt; vRAServer = $vcVM.vCenter
        }) | Out-Null
    }
}

# ============================================================================
# FINAL REPORTING
# ============================================================================
# (Standard HTML Generation)
$tableRows = ""
foreach ($item in ($finalReportList | Sort-Object VMName)) {
    $tableRows += "<tr><td>$($item.VMName)</td><td>$($item.DeploymentName)</td><td>$($item.RequestStatus)</td><td>$($item.RequestedBy)</td><td>$($item.InitiatedAt)</td><td>$($item.vRAServer)</td></tr>"
}

$html = "<html><style>body{font-family:Arial;} table{width:100%;border-collapse:collapse;} th{background:#2196F3;color:white;padding:10px;} td{border:1px solid #ddd;padding:8px;}</style><body>"
$html += "<h2>VM Deletion & Lifecycle Report</h2><table><thead><tr><th>VM Name</th><th>Deployment</th><th>Status</th><th>Action By</th><th>Timestamp</th><th>Source</th></tr></thead>"
$html += "<tbody>$tableRows</tbody></table></body></html>"

Send-MailMessage -To $script:smtpTo -From $script:smtpFrom -Subject $script:smtpSubject -Body $html -BodyAsHtml -SmtpServer $script:smtpServer -Port $script:smtpPort -UseSsl
Write-Log "Process Complete." "SUCCESS"
